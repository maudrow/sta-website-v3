1
00:00:02,700 --> 00:00:04,860
Audrow Nash: This is a
conversation with Brett Aldrich

2
00:00:04,890 --> 00:00:09,330
who is the CEO of a Robosoft AI.
Robosoft AI develops and

3
00:00:09,330 --> 00:00:12,750
maintains SMAC, which is a
library that aims to make it

4
00:00:12,780 --> 00:00:17,370
easier for roboticists to
control robot behavior. One of

5
00:00:17,370 --> 00:00:21,360
the key ideas in SMAC is that a
finite state machines, we'll be

6
00:00:21,360 --> 00:00:23,880
referring to finite state
machines a lot in this

7
00:00:23,880 --> 00:00:27,210
interview, so I'll explain what
they are. Before we start.

8
00:00:27,870 --> 00:00:32,430
Imagine that you have a lawn
mowing robot. Imagine that that

9
00:00:32,430 --> 00:00:35,160
robot is powered off, and that
you turn it on by pushing a

10
00:00:35,160 --> 00:00:40,590
button, it boots up and drives
to a field to mow. When it gets

11
00:00:40,590 --> 00:00:45,000
to the field, it starts mowing.
Once it finishes mowing, it

12
00:00:45,000 --> 00:00:50,550
drives home and powers off. This
robot has states like powered

13
00:00:50,550 --> 00:00:56,130
off, booting up driving, and
mowing. The robot also has

14
00:00:56,130 --> 00:01:01,170
transitions that occur on
events, such as when the robot

15
00:01:01,170 --> 00:01:05,340
is turned on by you pressing the
power button, or the robot

16
00:01:05,370 --> 00:01:10,980
arrives at the grass to mow
these transitions change the

17
00:01:10,980 --> 00:01:15,150
robot from one state to another.
For example, the event of

18
00:01:15,150 --> 00:01:18,690
arriving at the field to mow
could transition the robot from

19
00:01:18,690 --> 00:01:24,270
the state of driving to mowing.
So summarizing, a finite state

20
00:01:24,270 --> 00:01:30,300
machine is something made up of
states like driving, and mowing,

21
00:01:30,930 --> 00:01:36,180
and transitions when the robot
has reached the destination, or

22
00:01:36,210 --> 00:01:40,110
when it has finished mowing.
This is the sense think act

23
00:01:40,110 --> 00:01:44,100
Podcast. I'm Audrow Nash. Thank
you to our founding sponsor open

24
00:01:44,100 --> 00:01:48,660
robotics. And now here's my
conversation with Brett Aldrich.

25
00:01:50,670 --> 00:01:51,930
Would you introduce yourself?

26
00:01:52,800 --> 00:01:54,420
Brett Aldrich: My name is Brett
Aldrich, and I'm the author of

27
00:01:54,420 --> 00:01:57,720
Smak. State Machine library for
robotic applications written in

28
00:01:57,720 --> 00:02:02,190
C Plus Plus, I'm also the
founder of robust soft AI. Robot

29
00:02:02,190 --> 00:02:05,250
soft. We're the keepers of the
smack tool chain. We're also the

30
00:02:05,250 --> 00:02:08,490
creators of the smack to runtime
analyzer. A graphical

31
00:02:08,490 --> 00:02:10,980
application lets you visualize
your state machines both

32
00:02:10,980 --> 00:02:12,240
statically and at runtime.

33
00:02:13,020 --> 00:02:16,680
Audrow Nash: Hmm. And what so
can you start at a high level

34
00:02:16,680 --> 00:02:20,640
and explain what SMAC is, and
then what its motivation is?

35
00:02:21,030 --> 00:02:21,690
Sure.

36
00:02:22,110 --> 00:02:25,110
Brett Aldrich: SMACC is a state
machine library for robotic

37
00:02:25,110 --> 00:02:32,220
applications. I'd like to
describe it as dealing with the

38
00:02:32,340 --> 00:02:37,050
highest level of task planning
and management on a robotic

39
00:02:37,050 --> 00:02:42,390
system. It has many unique
features. And.

40
00:02:55,950 --> 00:02:59,010
Audrow Nash: Okay, so it's a,
it's a high level state machine

41
00:02:59,010 --> 00:03:04,410
library that helps you figure
out so you get to control your

42
00:03:04,410 --> 00:03:06,840
robotics application with it.

43
00:03:07,950 --> 00:03:10,380
Brett Aldrich: It's a control,
it's an architecture for

44
00:03:10,380 --> 00:03:17,580
control. And a couple of things
about it. You know, when you're

45
00:03:17,580 --> 00:03:21,780
writing your state machine, what
one it it provides a tight

46
00:03:21,810 --> 00:03:28,650
integration with. With Ross,
allowing you to generate events

47
00:03:28,650 --> 00:03:34,050
for Ross topics, services
actions right out of the box. It

48
00:03:34,050 --> 00:03:38,910
also offers a reference library
of state machines that are

49
00:03:38,910 --> 00:03:41,340
guaranteed to compile and run
right out of the box.

50
00:03:41,700 --> 00:03:44,040
Audrow Nash: So by reference
library, you mean a bunch of

51
00:03:44,040 --> 00:03:47,550
state machines you can already
use for specific things. Okay.

52
00:03:47,580 --> 00:03:51,120
Brett Aldrich: Exactly, exactly.
With, with simulation included

53
00:03:51,120 --> 00:03:55,350
for many of them. Gotcha. It
also offers a client library.

54
00:03:55,680 --> 00:04:01,830
And this, this is part of the
architecture of SMAC. That

55
00:04:02,700 --> 00:04:07,590
allows Ross users to use Ross
packages like move it to or nav

56
00:04:07,590 --> 00:04:13,710
to right out of the box. And it
also provides a pathway for

57
00:04:13,710 --> 00:04:19,350
other Ross packages. And for the
interfaces of those packages to

58
00:04:19,350 --> 00:04:23,100
be developed by specialists that
are then tied to your state

59
00:04:23,100 --> 00:04:27,300
machine it all of these features
have the effect of dramatically

60
00:04:27,300 --> 00:04:31,950
lowering the bar for new
developers to get started in

61
00:04:31,950 --> 00:04:35,610
Ross, and then in programming in
general controlling their robot.

62
00:04:38,280 --> 00:04:41,670
I can go on quite a bit longer
about this, but I would say so

63
00:04:41,670 --> 00:04:44,760
it's a good high level overview
of what SMAC is,

64
00:04:45,150 --> 00:04:49,410
Audrow Nash: is it kind of so
that if I if I'm using smack, I

65
00:04:49,410 --> 00:04:56,970
can kind of compose more complex
behaviors out of almost like

66
00:04:57,000 --> 00:05:01,710
blocks that will affect their
behavior and I can, I don't

67
00:05:01,710 --> 00:05:04,500
know, like, if I have this
sensor, I can run use this block

68
00:05:04,500 --> 00:05:07,890
to send out the data? Or is that
how it looks kind of like a

69
00:05:07,890 --> 00:05:09,990
bunch of blocks that I can
compose together?

70
00:05:10,290 --> 00:05:12,510
Brett Aldrich: Yes, yes, you
have, you have state you have

71
00:05:12,510 --> 00:05:16,620
states, right? That you can let
us to divide your problems. You

72
00:05:16,620 --> 00:05:21,120
have hierarchy, which does much
the same thing. You also have

73
00:05:21,390 --> 00:05:25,260
the concepts of orthogonal,
which are like boxes that allow

74
00:05:25,260 --> 00:05:30,030
you to modularize the physical
subsystems on a robot.

75
00:05:31,860 --> 00:05:34,380
Audrow Nash: Okay, and by that
you mean kind of control them

76
00:05:34,380 --> 00:05:38,070
independently or use them into
basically, right. Can you give

77
00:05:38,070 --> 00:05:40,050
me a more an example, I suppose?

78
00:05:40,080 --> 00:05:43,410
Brett Aldrich: Yeah, absolutely.
In fact, I'm gonna show a robot

79
00:05:43,410 --> 00:05:48,090
that that was recently built
using smack as an example. So

80
00:05:48,150 --> 00:05:51,450
this robot is from field work
robotics, it was built by them

81
00:05:51,450 --> 00:05:55,890
along with ourselves in Bosch,
India. And as you can see,

82
00:05:55,920 --> 00:06:01,350
there's four robot arms and a
couple of trays, and navigation

83
00:06:01,350 --> 00:06:05,520
based, so looks like a fruit
picking robot or exactly. It

84
00:06:05,520 --> 00:06:12,000
picks raspberries. Yeah. And it
was based on the work of Dr.

85
00:06:12,210 --> 00:06:15,570
Sutton's at the University of
Plymouth and his soft robotics

86
00:06:15,570 --> 00:06:15,990
lab.

87
00:06:16,410 --> 00:06:19,080
Audrow Nash: So that just to
describe it for the audio

88
00:06:19,080 --> 00:06:21,840
listeners, it's kind of like a
big moving cart with four

89
00:06:21,840 --> 00:06:26,130
different arms. That probably it
that's on wheels and probably

90
00:06:26,130 --> 00:06:30,330
drives through and picks stuff
for it. Would you say? That's,

91
00:06:30,480 --> 00:06:33,540
that's a good description of it,
I think to add Exactly, exactly.

92
00:06:34,170 --> 00:06:35,880
Okay, so use this.

93
00:06:36,060 --> 00:06:40,410
Brett Aldrich: So each
orthogonal, contains an arm. So

94
00:06:40,410 --> 00:06:45,270
there's this orthogonal one with
each arm. Another thought for

95
00:06:45,270 --> 00:06:50,580
the base, there's probably two
more orthogonal is for there was

96
00:06:50,580 --> 00:06:55,440
like, like a packaging. Not
exactly sure what you call it,

97
00:06:55,440 --> 00:06:58,920
almost like a gantry. A small
gantry inside for for packaging,

98
00:06:58,920 --> 00:07:02,340
the raspberries. You probably
also have your cameras with

99
00:07:02,340 --> 00:07:05,700
perception, all of these would
would go into an orthogonal

100
00:07:05,820 --> 00:07:10,140
using a model of let's say, the
human body. You might have

101
00:07:10,410 --> 00:07:14,550
orthogonal for your eyes,
another two orthogonal for each

102
00:07:14,550 --> 00:07:17,280
arm. Yet another orthogonal, so
is

103
00:07:17,280 --> 00:07:19,950
Audrow Nash: it? Can you think
of it kind of like a degree of

104
00:07:19,950 --> 00:07:25,710
freedom? Yes, in a sense, yeah,
you can. Yeah, cuz, so I mean,

105
00:07:26,700 --> 00:07:30,720
I'm thinking of so orthogonal,
which means, like, it has a

106
00:07:30,720 --> 00:07:33,630
technical definition, which I
think is it's the dot product is

107
00:07:33,630 --> 00:07:37,890
zero, or something like this,
right? So it basically means

108
00:07:37,890 --> 00:07:42,990
perpendicular, but it allows for
higher dimensions. Right? And so

109
00:07:42,990 --> 00:07:46,500
it's like a new dimension, a new
dimension and state space kind

110
00:07:46,500 --> 00:07:46,920
of thing.

111
00:07:47,130 --> 00:07:52,140
Brett Aldrich: You know, I, the
term that is I use it comes from

112
00:07:52,470 --> 00:07:56,310
comes from boost HR. And it was
always tied to physical

113
00:07:56,310 --> 00:08:01,770
subsystems. But actually from
boosted, charted, inherited

114
00:08:01,800 --> 00:08:08,460
originally from David Harold's
1987. Paper on state charts. So

115
00:08:09,600 --> 00:08:15,960
in 1987, David Harrell came up
with state charts. And he

116
00:08:15,960 --> 00:08:20,580
developed that formalism that I
guess you'd call it an extension

117
00:08:20,580 --> 00:08:23,460
of the formalism of state
machines while working as a

118
00:08:23,460 --> 00:08:27,450
consultant, Israeli Aircraft
industries, and in particularly,

119
00:08:27,480 --> 00:08:32,670
in particular working on an
avionics system. And so in that,

120
00:08:32,730 --> 00:08:37,200
in that context of a fighter
jet, each orthogonal basically

121
00:08:38,160 --> 00:08:42,450
was tied to a physical
subsystem. Hmm. Yeah. As opposed

122
00:08:42,450 --> 00:08:46,080
to, I think a more like a
mathematical interpretation,

123
00:08:46,110 --> 00:08:47,550
which is, I think, where you are
going more

124
00:08:47,549 --> 00:08:49,739
Audrow Nash: with yes, that's
where I know the word from I

125
00:08:49,739 --> 00:08:54,239
haven't heard it. And this in
this this state machine sense.

126
00:08:54,839 --> 00:08:58,319
Okay. So then, so you have all
these different orthogonal, I'm

127
00:08:58,319 --> 00:09:01,439
thinking of them kind of like a
general degree of freedom, where

128
00:09:01,439 --> 00:09:05,939
multiple so if you said a full
arm is one, it's kind of like a

129
00:09:05,939 --> 00:09:09,239
subsystem. And then maybe you
want to do things with it. And

130
00:09:09,239 --> 00:09:11,849
maybe that subsystem has several
degrees of freedom, like a

131
00:09:11,849 --> 00:09:15,209
shoulder and an elbow and a
wrist, which is controlling it

132
00:09:15,209 --> 00:09:19,019
independently of other parts of
the system. Is that kind of the

133
00:09:19,019 --> 00:09:22,169
core part? It's an orthogonal is
something that is controlled

134
00:09:22,169 --> 00:09:27,689
independent of other parts of
the system? Yes. Okay. Yes. So

135
00:09:27,689 --> 00:09:31,619
I'm thinking generalized degree
of freedom. So multiple degrees

136
00:09:31,619 --> 00:09:32,099
of freedom

137
00:09:32,429 --> 00:09:36,479
Brett Aldrich: is probably
modularity. Yeah. Yep. Yep.

138
00:09:36,630 --> 00:09:38,970
Audrow Nash: And can you have
can you have orthogonal in

139
00:09:38,970 --> 00:09:43,320
orthogonal? Like, if I have an
orthogonal that's my arm? Can I

140
00:09:43,320 --> 00:09:46,680
have that broken down into
orthogonal is that are my

141
00:09:46,680 --> 00:09:51,780
shoulder, wrist and elbow? Is
that kind of this hierarchy?

142
00:09:53,100 --> 00:09:53,640
Okay,

143
00:09:53,820 --> 00:09:57,810
Brett Aldrich: so I think the
short answer is no. The

144
00:09:57,810 --> 00:10:00,450
orthogonal is can be quite
complex, and so you deaf We can

145
00:10:00,450 --> 00:10:03,930
have multi joint, real, you
know, arms in

146
00:10:03,929 --> 00:10:05,729
Audrow Nash: one orthogonal,
orthogonal.

147
00:10:07,080 --> 00:10:11,160
Brett Aldrich: But one of the
things that that that we did we

148
00:10:11,160 --> 00:10:18,060
being Pablo and I in terms of
the robot, sorry, what? Oh,

149
00:10:18,569 --> 00:10:20,369
Audrow Nash: sorry, I thought we
were still talking about the

150
00:10:21,119 --> 00:10:22,289
robot for picking

151
00:10:22,319 --> 00:10:24,839
Brett Aldrich: things in Yeah,
not for that robot in

152
00:10:24,839 --> 00:10:29,459
particular, but in, in SMAC, as
a library and viewing smack in a

153
00:10:29,459 --> 00:10:34,919
historical context. One of the
things that that we we did was,

154
00:10:35,309 --> 00:10:39,929
we took the orthogonal concept
that David Harrell and Andreas

155
00:10:39,929 --> 00:10:45,209
Huber Dawn, put into, into, you
know, instantiated essentially

156
00:10:45,209 --> 00:10:49,169
in boost a chart, and we
simplify, and because up until

157
00:10:49,169 --> 00:10:55,409
that point, so I think the world
of Andreas Huber Donny, but he

158
00:10:55,409 --> 00:11:00,689
didn't, he never really used the
orthogonal and the orthogonal in

159
00:11:00,689 --> 00:11:07,949
a, in a, in like a context of a
PC really don't make that much

160
00:11:07,949 --> 00:11:13,139
sense. And so we took them and
began to use them, and we saw

161
00:11:13,499 --> 00:11:18,029
shortcomings with them. And so
we, we simplified the orthogonal

162
00:11:18,029 --> 00:11:23,969
structure and, and then what we
did was we added this, this

163
00:11:23,999 --> 00:11:28,799
architecture part of clients and
client behaviors. So inside of

164
00:11:28,799 --> 00:11:31,859
each orthogonal, so visualizing,
and orthogonal is a box, right,

165
00:11:31,889 --> 00:11:40,529
a box inside an eight box, there
are generally two to further

166
00:11:40,529 --> 00:11:45,269
boxes inside that have a client
and a client behavior. The

167
00:11:45,269 --> 00:11:50,069
client is has a lifetime of the
entire state machine. So if you

168
00:11:50,099 --> 00:11:53,399
if you have something that you
have some piece of code that you

169
00:11:53,399 --> 00:11:57,179
want to effect that robot in
every state, then you just put

170
00:11:57,179 --> 00:12:00,809
it in the client. So this would
be something like, let's say,

171
00:12:01,769 --> 00:12:05,159
you've got a connection to a
robot arm. And if at any time

172
00:12:05,159 --> 00:12:08,369
you lose that connection, you
want some event to be thrown,

173
00:12:08,399 --> 00:12:11,639
you put that in the client, the
client behavior contrast,

174
00:12:11,909 --> 00:12:15,359
Audrow Nash: oh, it's like a
global state in a sense. Yeah,

175
00:12:15,389 --> 00:12:19,439
Brett Aldrich: there is there
was a blow valatie to it. It's a

176
00:12:19,439 --> 00:12:24,269
different type of state, though,
in that. Typically, in smack,

177
00:12:24,269 --> 00:12:29,939
we're talking about states in a
control sense. The states that

178
00:12:29,939 --> 00:12:34,469
are stored inside clients are
more like, like an image state.

179
00:12:35,459 --> 00:12:37,739
This gets confusing actually,
what it's like when you hear

180
00:12:37,739 --> 00:12:40,229
about something like state
estimation, it's more like an

181
00:12:40,229 --> 00:12:44,639
image in a sense, right? So that
part is stored, whereas the

182
00:12:44,639 --> 00:12:47,399
control states are always
explicitly controlled within

183
00:12:47,429 --> 00:12:52,139
smack the state machine back to
the talk. So if you've got

184
00:12:52,139 --> 00:12:55,019
clients that are scoped to the
life of the state machine and

185
00:12:55,019 --> 00:12:57,449
client behaviors, they're only
scoped to the life of that

186
00:12:57,449 --> 00:13:04,829
state. And and you can have more
than one client behavior at any

187
00:13:04,829 --> 00:13:08,129
one time. And I would say that
that's where really the

188
00:13:08,129 --> 00:13:12,539
modularity comes in. That's
basically how you interact with

189
00:13:12,539 --> 00:13:15,389
the orthogonal is through the
client behaviors, the client

190
00:13:15,389 --> 00:13:18,179
that sets up, you know, would
say, all the communication and

191
00:13:18,179 --> 00:13:20,489
all the kind of stuff that you
want throughout the lifetime of

192
00:13:20,489 --> 00:13:24,539
the state machine. But the
particular behaviors are in are

193
00:13:24,539 --> 00:13:27,059
in these modular client
behaviors that

194
00:13:27,870 --> 00:13:32,250
Audrow Nash: so the client is
like, it's the manager of, but

195
00:13:32,280 --> 00:13:36,330
so how do you call it so you
have the client and the client

196
00:13:36,360 --> 00:13:40,920
is in a? What was the word
again, orthogonal? That so you

197
00:13:40,920 --> 00:13:43,830
haven't or thought so you have
like a global state, and then

198
00:13:43,830 --> 00:13:47,820
from the global state, you have
your orthogonal, your orthogonal

199
00:13:47,820 --> 00:13:52,170
is some piece that can be
controlled independently of all

200
00:13:52,170 --> 00:13:56,070
of the other orthogonal, and
then inside that orthogonal, you

201
00:13:56,070 --> 00:13:59,460
have a client, and that client
is going to control that

202
00:13:59,460 --> 00:14:03,060
orthogonal to run several
different behaviors given the

203
00:14:03,060 --> 00:14:07,710
state. Am I understanding
correctly? Not the client

204
00:14:07,710 --> 00:14:10,680
Brett Aldrich: and the client
behavior. But okay, what's the

205
00:14:11,070 --> 00:14:14,010
sorry? What's the client
behavior? The client behavior is

206
00:14:14,010 --> 00:14:17,130
different in that its lifetime
is scoped only to that state?

207
00:14:18,840 --> 00:14:20,850
Audrow Nash: And how are we
talking about states? And this

208
00:14:20,850 --> 00:14:24,960
You were saying something about
images? And what is the state in

209
00:14:24,960 --> 00:14:25,380
this?

210
00:14:25,680 --> 00:14:27,420
Brett Aldrich: Yeah, we're
talking about it thinking from a

211
00:14:27,420 --> 00:14:31,920
control structure. So going back
from like, a global, yep, the

212
00:14:31,920 --> 00:14:34,980
state machine is essentially
synonymous with the application

213
00:14:34,980 --> 00:14:38,970
layer. Right? So the state
machine is your application. And

214
00:14:38,970 --> 00:14:42,600
there's one state machine on any
one robot I mean, one time,

215
00:14:42,930 --> 00:14:46,050
okay. Many libraries have like
where you start nesting state

216
00:14:46,050 --> 00:14:49,170
machines inside of each other. I
don't, we don't do that with you

217
00:14:49,170 --> 00:14:52,380
don't like it. Yeah, okay. I
think it it creates problems

218
00:14:52,380 --> 00:14:58,740
with data with routing the data
and other problems. So, so you

219
00:14:58,740 --> 00:15:02,190
have a state machine that It is
your application. And within

220
00:15:02,190 --> 00:15:05,370
that state machine, you have a
series of states, and they can

221
00:15:05,370 --> 00:15:08,910
be grouped in different levels
of or higher of hierarchy. So

222
00:15:08,940 --> 00:15:12,720
let's say let's say back to

223
00:15:12,720 --> 00:15:16,620
Audrow Nash: that vegetable
picking robot. Like that would

224
00:15:16,620 --> 00:15:20,640
be a nice concrete example, to
talk about this. Okay.

225
00:15:21,539 --> 00:15:24,689
Brett Aldrich: Okay, yeah, we'll
use that. And also, we'll blend

226
00:15:24,689 --> 00:15:29,339
in an example that I heard about
it for the DARPA subterranean

227
00:15:29,339 --> 00:15:37,109
challenge. So in starting out,
or in one of these teams that

228
00:15:37,829 --> 00:15:40,949
I've had the pleasure of
speaking with people involved,

229
00:15:41,369 --> 00:15:45,269
they started out with a four
state state machine. Okay, so

230
00:15:45,389 --> 00:15:50,069
four states. So in that, in that
example, you would have one

231
00:15:50,069 --> 00:15:53,429
state machine with four states
moving forward, nor hierarchy at

232
00:15:53,429 --> 00:15:53,909
this point, I

233
00:15:53,910 --> 00:15:57,480
Audrow Nash: see, I see one of
my points of confusion. So state

234
00:15:57,480 --> 00:16:01,200
in robotics, and like a control
sense can mean like, the thing

235
00:16:01,200 --> 00:16:04,710
that defines where the robot is.
So this joint has this degree,

236
00:16:05,220 --> 00:16:07,380
this angle, this joint has the
next one. So I was trying to

237
00:16:07,380 --> 00:16:10,140
understand this, but you're
using state as an in a state

238
00:16:10,140 --> 00:16:14,820
machine. So is a specific state
that the state machine is in.

239
00:16:14,880 --> 00:16:17,490
And that's what we're talking
about when we're saying stuck in

240
00:16:17,490 --> 00:16:20,490
this. Okay. So then we're saying
we have a finite number of

241
00:16:20,490 --> 00:16:25,350
states, those control basically
the behaviors, or we can do

242
00:16:25,350 --> 00:16:29,430
different behaviors in different
states. And we move through from

243
00:16:29,430 --> 00:16:33,780
one state to another as the
operation proceeds or something

244
00:16:33,780 --> 00:16:37,110
like this based on Okay,
exactly, I see an ambiguity,

245
00:16:37,140 --> 00:16:40,770
okay, that I was confused by.
But it is it's a confusing

246
00:16:40,770 --> 00:16:46,710
thing. And especially, yeah,
we'll just have to say state for

247
00:16:46,710 --> 00:16:49,440
state machines or something and
states for controls or

248
00:16:49,440 --> 00:16:52,680
something. And that will help
keep me clear with it. Or I'll

249
00:16:52,680 --> 00:16:56,340
try to make it explicit anyways.
Okay, so you have your state.

250
00:16:56,639 --> 00:16:59,009
Brett Aldrich: So this is back
to this example, we have four

251
00:16:59,009 --> 00:17:03,479
states, right? So, and we'll
just name them state, 123, and

252
00:17:03,479 --> 00:17:06,899
four. So in each of these
states, going back to the

253
00:17:06,899 --> 00:17:10,079
example of that field, work
robotics robot, we would have,

254
00:17:10,109 --> 00:17:13,859
let's say, Okay, we got one
orthogonal for each arm, one for

255
00:17:13,859 --> 00:17:20,459
a base, one for the two
gantries, that's for six, seven,

256
00:17:20,459 --> 00:17:25,049
and let's say one for perception
eight. Okay, so in each of those

257
00:17:25,049 --> 00:17:30,029
four states, you're going to see
eight orthogonal 's, that okay,

258
00:17:30,149 --> 00:17:35,129
inside you, each one will have a
client in every state. And then,

259
00:17:35,399 --> 00:17:43,499
depending on what behaviors we
want that robot to express, we

260
00:17:43,499 --> 00:17:47,069
arranged the client behaviors
accordingly. And so it provides

261
00:17:47,069 --> 00:17:50,489
like a modular control structure
for each subsystem of the robot.

262
00:17:51,540 --> 00:17:54,600
Audrow Nash: Gotcha. So if you
are, yeah, and the state

263
00:17:54,599 --> 00:17:58,199
Brett Aldrich: basically serves
is like, this gets more into

264
00:17:58,199 --> 00:18:00,329
like the sub state architecture
of smack, but

265
00:18:02,700 --> 00:18:08,550
those, the client behaviors, and
the clients throw events based

266
00:18:08,550 --> 00:18:15,060
on what happens outside, you
know, so smack is a single node,

267
00:18:15,330 --> 00:18:18,900
operate back to this example.
Smack is a single process

268
00:18:18,930 --> 00:18:22,590
operating at runtime. And you're
also going to have, you know,

269
00:18:22,590 --> 00:18:24,810
other processes on this system,
you're going to probably have

270
00:18:24,810 --> 00:18:29,130
nav two, you're going to have
move it. One with perception.

271
00:18:29,400 --> 00:18:34,560
And so when those other nodes
communicate via let's say, Ross

272
00:18:34,560 --> 00:18:40,860
topics or services, the the SMAC
clients will turn those

273
00:18:40,860 --> 00:18:46,110
messages, which you'll specify
into events. And then those

274
00:18:46,110 --> 00:18:50,760
events are that's cool ordinated
by the state, like, like a

275
00:18:50,760 --> 00:18:54,630
conductor would, you know, on
this event, we transition to

276
00:18:54,630 --> 00:19:00,360
this state, at the end of the
day states are a lot of people,

277
00:19:00,840 --> 00:19:03,750
you might you might incoming to
state machines, you might think

278
00:19:03,750 --> 00:19:07,980
that states, that's the state
machines are about states, and

279
00:19:07,980 --> 00:19:12,690
they're really not they're about
events. And okay, it's through

280
00:19:12,750 --> 00:19:19,410
events that you begin the
subject of states almost, it's

281
00:19:19,410 --> 00:19:21,570
like, it begs the question, you
know, like, when you have an

282
00:19:21,570 --> 00:19:25,080
event, you have what was before
and what's after, right?

283
00:19:25,080 --> 00:19:29,280
Audrow Nash: And then can you
define an event? Can you define

284
00:19:29,310 --> 00:19:29,790
event,

285
00:19:29,940 --> 00:19:33,480
Brett Aldrich: an event is
general explanations. It's like

286
00:19:33,480 --> 00:19:35,760
some type of discrete.

287
00:19:37,560 --> 00:19:39,810
Audrow Nash: So in Ross, it
would be have I received this

288
00:19:39,810 --> 00:19:44,100
message or not sure. Is the
event is the message occurring,

289
00:19:44,400 --> 00:19:45,210
this kind of thing.

290
00:19:45,480 --> 00:19:49,230
Brett Aldrich: Exactly. Exactly.
Are they completing or

291
00:19:49,619 --> 00:19:51,569
Audrow Nash: are they action
completing or something like

292
00:19:51,569 --> 00:19:55,649
that? So if I'm using naff to,
and I want to move from one spot

293
00:19:55,679 --> 00:19:59,999
to another spot, the action
completing of me moving to the

294
00:19:59,999 --> 00:20:04,199
To location could be the event.
So it says I'm in this location

295
00:20:04,619 --> 00:20:07,019
event has occurred, I then
occur.

296
00:20:07,050 --> 00:20:09,870
Brett Aldrich: And then when
that event is occurred in some

297
00:20:09,900 --> 00:20:14,970
in smack in a state Yeah, you
specify often where you will

298
00:20:14,970 --> 00:20:17,280
like what the next state you'll
transition to is.

299
00:20:17,730 --> 00:20:20,640
Audrow Nash: So are we always
transitioning on events? Or

300
00:20:20,670 --> 00:20:23,850
should you always go to another
state, or you can probably stay

301
00:20:23,850 --> 00:20:27,360
in the same state and have
several events. I'm just trying

302
00:20:27,360 --> 00:20:32,340
to think of more complex
behavior. But so are events

303
00:20:32,340 --> 00:20:35,460
always used? They're not always
used for transitions, but they

304
00:20:35,730 --> 00:20:40,830
Brett Aldrich: not always but
and here, we get into the minute

305
00:20:40,830 --> 00:20:45,660
you start using events, you
start using more. One of the

306
00:20:45,810 --> 00:20:50,370
another one of the features we
added to I'm saying these are

307
00:20:50,370 --> 00:20:52,950
things that I think are
interesting, historically

308
00:20:52,950 --> 00:20:56,310
insensitive, like what's unique
about smack, you know, versus a

309
00:20:56,310 --> 00:20:59,550
blue state chart. And what
happened before we we brought in

310
00:20:59,550 --> 00:21:01,680
the concept of state reactors.

311
00:21:03,119 --> 00:21:05,579
Audrow Nash: Let us define a few
things just because there's a

312
00:21:05,579 --> 00:21:07,649
few things that I don't quite
understand before we get into

313
00:21:07,649 --> 00:21:12,659
state reactors. So I don't quite
understand the difference

314
00:21:12,719 --> 00:21:15,959
between clients and client
behaviors.

315
00:21:16,380 --> 00:21:20,730
Brett Aldrich: Sure, it comes
down to the lifetime client, oh,

316
00:21:20,820 --> 00:21:25,200
or lifetime to the state
machine. And behaviors have a

317
00:21:25,200 --> 00:21:26,790
lifetime specific to that event.

318
00:21:29,460 --> 00:21:35,040
Audrow Nash: Oh, okay. So so, so
client behaviors are just for

319
00:21:35,040 --> 00:21:39,210
behaviors? Or how does it what
why are they named that? Let me

320
00:21:39,210 --> 00:21:42,060
just see, I think my smoke alarm
is gone, or some smoke alarm?

321
00:21:45,119 --> 00:21:46,289
Brett Aldrich: Sounds like a
smoke alarm.

322
00:21:46,830 --> 00:21:49,560
Audrow Nash: I do hear a beep
beep. We just filter it out in

323
00:21:49,560 --> 00:21:54,210
the thing. So long as I don't
smell smoke and whatever. Yeah.

324
00:21:54,240 --> 00:21:54,780
Okay,

325
00:21:54,990 --> 00:22:03,510
Brett Aldrich: you do get out of
there. Yeah, for sure. Just gets

326
00:22:03,510 --> 00:22:06,960
into like the systematic
architecture of code layout SMAC

327
00:22:06,960 --> 00:22:11,130
offers. So let's say you have
something that you want that

328
00:22:11,130 --> 00:22:15,600
robot to do, like some type of
event that you want to respond

329
00:22:15,600 --> 00:22:19,770
to in a particular way. But you
want that to be throughout the

330
00:22:19,800 --> 00:22:22,590
like every state of the state
machine, you put that code in

331
00:22:22,590 --> 00:22:22,980
the client.

332
00:22:25,350 --> 00:22:28,920
Audrow Nash: I see. Okay, so and
then. So you're kind of you

333
00:22:28,920 --> 00:22:34,350
generate these client behaviors,
when the event happens. And that

334
00:22:34,350 --> 00:22:37,170
will take care of a specific,
it's the kind of created and

335
00:22:37,170 --> 00:22:42,690
destroyed on a specific event,
whereas the other one occurs all

336
00:22:42,690 --> 00:22:46,500
the time, I'm thinking of them,
like, kind of simple, but for

337
00:22:46,500 --> 00:22:49,320
like web pages, or something
like you always want to load

338
00:22:49,320 --> 00:22:51,630
this one thing, it's going to
happen no matter what page you

339
00:22:51,630 --> 00:22:54,780
do. So it's like the header or
something, that's always going

340
00:22:54,780 --> 00:22:57,570
to be the same. And then your
client behaviors would be the

341
00:22:57,570 --> 00:23:01,950
very specific things that are on
a specific route, in this case,

342
00:23:02,010 --> 00:23:03,540
yep. Is that a fair way to think
about it?

343
00:23:03,570 --> 00:23:07,410
Brett Aldrich: It's not very
good, and the only nitpicking

344
00:23:07,410 --> 00:23:10,260
thing I would have there is that
it's there not so much. The

345
00:23:10,260 --> 00:23:14,160
client behaviors aren't created
with events, they're created

346
00:23:14,190 --> 00:23:20,910
with new states. So one state to
another, that's when the client

347
00:23:20,910 --> 00:23:22,620
behavior is created at runtime.

348
00:23:23,099 --> 00:23:29,309
Audrow Nash: Okay, I see. Okay.
And then you're gonna so there

349
00:23:29,309 --> 00:23:31,229
was another thing that you were
going to introduce?

350
00:23:32,220 --> 00:23:35,910
Brett Aldrich: Yeah, state
reactors. So this is another

351
00:23:35,910 --> 00:23:40,260
type of this is all part of the
the sub state architecture. So

352
00:23:40,260 --> 00:23:43,740
like, once once we're in a state
and looking down at the pieces

353
00:23:43,740 --> 00:23:47,820
inside of it, what state
reactors do is so

354
00:23:47,849 --> 00:23:53,759
Audrow Nash: what so in the sub
state what composes a sub state?

355
00:23:53,789 --> 00:23:59,189
Is it so other states within
states or are there so others?

356
00:24:00,540 --> 00:24:04,890
Brett Aldrich: We do have we do
have? We do have hierarchy? Yep.

357
00:24:04,890 --> 00:24:09,330
But when when we're talking
about the the, but to in the

358
00:24:09,330 --> 00:24:13,320
hierarchy, one thing that that
is unique and smacker? Or maybe,

359
00:24:13,500 --> 00:24:20,910
I don't know, what's one
feature? You we break down the

360
00:24:20,910 --> 00:24:26,820
library into having container
states and leaf states and it's

361
00:24:26,820 --> 00:24:31,890
the leaf state that has the
orthogonal and the full substate

362
00:24:31,890 --> 00:24:35,670
architecture, V. Okay. The
container states don't by

363
00:24:35,670 --> 00:24:41,700
default. You can turn them on.
It's smack we follow the

364
00:24:41,700 --> 00:24:48,090
philosophy of we do things in a
certain implementation that you

365
00:24:48,090 --> 00:24:52,980
know, as we see that we think is
best but we try not to turn off

366
00:24:52,980 --> 00:24:57,480
like other ways of doing things
because some of the early

367
00:24:57,480 --> 00:25:01,200
clients that we had really
challenged my views of how they

368
00:25:01,200 --> 00:25:03,960
would interact with the system.
And I'm thinking to you, Bob

369
00:25:03,960 --> 00:25:12,270
peetha, gray, Orange. They, they
did things that I, what, what

370
00:25:12,270 --> 00:25:17,850
are you doing? You know, it took
me back. But, uh, but it totally

371
00:25:17,850 --> 00:25:22,110
valid way of running things. So
we try to leave those those

372
00:25:22,110 --> 00:25:25,080
sorts of things open anyway,
back to the hierarchy. So. So

373
00:25:25,080 --> 00:25:30,840
generally, there's always a leaf
state that has orthogonal and

374
00:25:30,840 --> 00:25:34,680
other things like that a state
reactor is is a just another one

375
00:25:34,680 --> 00:25:40,410
of these objects. And what it
does is it receives events and

376
00:25:40,410 --> 00:25:46,260
throws its own event. And so it
basically brings in second order

377
00:25:46,470 --> 00:25:54,300
events, the first ace, so we
came up with it. This is in

378
00:25:54,300 --> 00:25:59,940
like, mid 2018. And we just
begun the library in like, at

379
00:25:59,940 --> 00:26:04,500
the end of 2017. And we were
contacted by the company

380
00:26:04,500 --> 00:26:08,430
here.com. And they were working
on a self driving car at the

381
00:26:08,430 --> 00:26:15,840
time that it had a very
complicated array of six, like

382
00:26:15,840 --> 00:26:19,980
super high end cameras, was for
like a self driving car that

383
00:26:19,980 --> 00:26:23,700
would map you know, as well, and
what, what they wanted it to do

384
00:26:23,910 --> 00:26:29,220
was, you know, navigate from one
point to another, when it

385
00:26:29,220 --> 00:26:33,090
started up, it wanted to make
sure all the cameras were ready

386
00:26:33,090 --> 00:26:38,100
to go, and then drive, if
anything happened, stop, bring

387
00:26:38,100 --> 00:26:45,390
all the other cameras back on
line and go. And that led me to

388
00:26:45,390 --> 00:26:48,900
create the state reactors. And
so what we did is we have a

389
00:26:49,200 --> 00:26:52,800
state reactive called all events
go, and it's a runtime object

390
00:26:52,830 --> 00:26:56,700
that resides inside the state.
And it receives events from

391
00:26:56,700 --> 00:26:59,940
camera one, that camera to event
and once it's received it from

392
00:26:59,940 --> 00:27:02,550
all then it throws its own
event, and then the state

393
00:27:02,550 --> 00:27:09,030
transitions. It's become such a
popular, I'd almost say it's a

394
00:27:09,030 --> 00:27:14,400
state machine design pattern.
You know, we call it S T acquire

395
00:27:14,400 --> 00:27:19,950
sensors. And I don't know what
percentage of state, you know,

396
00:27:19,950 --> 00:27:22,200
we have in the reference
library, we have certain state

397
00:27:22,200 --> 00:27:25,140
machines that are extremely
simple. It's just like this one

398
00:27:25,140 --> 00:27:28,350
back and forth. So they don't
have it. But I think for all of

399
00:27:28,350 --> 00:27:31,110
the other state machines that
we've like, if there's a

400
00:27:31,170 --> 00:27:34,590
simulation video, I'm pretty
sure all of them have one of

401
00:27:34,590 --> 00:27:38,070
these SD acquire sensor states
and very early on in the

402
00:27:38,070 --> 00:27:39,540
execution chain.

403
00:27:41,040 --> 00:27:44,280
Audrow Nash: Gotcha. Okay, so
you have those that will kind of

404
00:27:44,280 --> 00:27:48,180
take information and they take
in all the events, and then when

405
00:27:48,390 --> 00:27:51,840
a specific condition is met,
they may event they may emit

406
00:27:51,840 --> 00:27:54,810
another event, and that can be
used to trigger some sort of

407
00:27:55,200 --> 00:27:58,590
transition or whatever might
occur. Correct. Okay.

408
00:27:59,220 --> 00:28:01,560
Brett Aldrich: They also, one
other thing too about him,

409
00:28:01,560 --> 00:28:04,140
that's I don't know, that might
be interesting for the

410
00:28:04,140 --> 00:28:10,620
specialist out there. They
they've set the stage for us to

411
00:28:10,650 --> 00:28:14,220
move ahead with cogeneration in
a new way, one of the things

412
00:28:14,220 --> 00:28:16,590
that's always cool state machine
libraries,

413
00:28:17,430 --> 00:28:20,520
Audrow Nash: when you try to
play code, or Yeah, well,

414
00:28:20,520 --> 00:28:20,970
boilerplate,

415
00:28:20,970 --> 00:28:26,010
Brett Aldrich: but also, like
graphical cogeneration. That one

416
00:28:26,010 --> 00:28:30,870
of the problems that that has
are always complicated, that is

417
00:28:31,140 --> 00:28:36,060
callback functions. But with
state reactors, you avoid that

418
00:28:36,510 --> 00:28:40,050
by with, you know, through these
second order events. And so

419
00:28:41,490 --> 00:28:45,960
yeah, and that's part of our
plans over the over the long

420
00:28:45,960 --> 00:28:49,740
run, you know, to build out an
entire tool chain along with the

421
00:28:49,890 --> 00:28:54,480
the ability to right now we have
this Mac to runtime analyzer,

422
00:28:54,480 --> 00:28:58,440
but we want to create a smack to
writer where you can, you know,

423
00:28:58,440 --> 00:29:02,850
graphically align your state
machine and have it auto

424
00:29:02,850 --> 00:29:06,300
generate the code, or at least
generate some of the code, you

425
00:29:06,300 --> 00:29:10,560
know, like, like a lattice
framework type thing. And, yeah,

426
00:29:10,860 --> 00:29:14,460
the only thing about that is
that, in my opinion, you have to

427
00:29:14,460 --> 00:29:20,820
do that last. Because if you do
that too early, and you've got

428
00:29:21,060 --> 00:29:24,570
some problems in your, you know,
in your architecture, you

429
00:29:24,570 --> 00:29:28,950
basically baked it in place. So,
yeah, so that's one of the

430
00:29:28,950 --> 00:29:32,640
things I'm really hoping to
accomplish with SMAC, in this

431
00:29:32,640 --> 00:29:35,910
current year is basically
getting more and more use cases,

432
00:29:36,630 --> 00:29:39,180
to a point where it's like,
okay, no, no, we've seen you

433
00:29:39,180 --> 00:29:42,510
know, we've got an idea about
every which way that the library

434
00:29:42,510 --> 00:29:45,660
could conceivably be used. I
don't know if we'll get all the

435
00:29:45,660 --> 00:29:46,410
way there, but,

436
00:29:46,530 --> 00:29:48,750
Audrow Nash: but if you get a
lot of them, then you have a

437
00:29:48,750 --> 00:29:51,030
fairly general solution, and
then it can be used for a lot of

438
00:29:51,030 --> 00:29:56,370
things. That'll be great. Yeah.
So one thing that I don't quite

439
00:29:56,700 --> 00:30:00,840
understand, well, I guess I'm
having trouble mapping The idea

440
00:30:00,840 --> 00:30:03,090
is together. So I understand
this architecture with the

441
00:30:03,090 --> 00:30:06,210
client behaviors and you have
your orthogonal and you have

442
00:30:06,210 --> 00:30:10,890
your states and things like
this. Can you explain kind of so

443
00:30:10,890 --> 00:30:14,940
like a simple application, say
say like that video of the

444
00:30:14,940 --> 00:30:19,980
fetch, sorting, the fetch, in
simulation, sorting cubes by

445
00:30:19,980 --> 00:30:27,330
color, okay, like, how do we go
from these states? And then the

446
00:30:27,330 --> 00:30:32,040
orthogonalize in and then how,
just like an idea of how all the

447
00:30:32,040 --> 00:30:35,220
systems work together to create
some reasonably complex

448
00:30:35,220 --> 00:30:41,790
behavior? Or can be a simpler
one, if that's kind of complex?

449
00:30:41,820 --> 00:30:44,160
Brett Aldrich: Yeah, maybe we'll
start with the dance bot

450
00:30:44,730 --> 00:30:47,940
example. We'll kind of dive into
that one a little bit. All

451
00:30:47,940 --> 00:30:53,850
right. Sure. In so for those
who, you know, who haven't seen

452
00:30:53,850 --> 00:30:58,710
it, the best spot to see the
dance bot example I can like it.

453
00:30:59,610 --> 00:31:04,380
Yeah, is in is in the the Ross
world 2021 presentation on smack

454
00:31:04,380 --> 00:31:10,770
to It's the opening video how we
link that all together.

455
00:31:12,000 --> 00:31:14,370
Audrow Nash: And just to
describe the video a bit, it's a

456
00:31:14,370 --> 00:31:20,670
robot that it's in a sort of
maze, and it goes to a location

457
00:31:20,670 --> 00:31:23,010
and then it drives until it hits
a wall, and then it goes back to

458
00:31:23,010 --> 00:31:26,550
its original location. And then
it goes out again, but slightly

459
00:31:26,550 --> 00:31:29,910
different angle from where it
was heading. So it makes kind of

460
00:31:29,910 --> 00:31:34,020
like a star pattern. And where
it goes, and it bumps each of

461
00:31:34,020 --> 00:31:36,240
the walls around it, and then it
goes back to its original

462
00:31:36,240 --> 00:31:38,940
location, and then it goes to
some other location to start

463
00:31:38,940 --> 00:31:42,690
doing the same pattern there.
And I believe the intention with

464
00:31:42,690 --> 00:31:45,240
this is to map out an
environment.

465
00:31:45,630 --> 00:31:48,390
Brett Aldrich: Not exactly it's
oh, there is there is a mapping

466
00:31:48,390 --> 00:31:52,620
that, that, that that does
happen. But it's really more

467
00:31:52,620 --> 00:31:58,710
about floor coverage. We were
modeling, you know, how how a

468
00:31:58,710 --> 00:32:03,570
robot might, you know, cover a
floor space in in modular ways.

469
00:32:05,190 --> 00:32:12,000
In that one, the robot navigates
to to global waypoints and

470
00:32:12,480 --> 00:32:20,640
begin, proceed to perform
dinners of superstate this is,

471
00:32:20,670 --> 00:32:23,400
so now we get into hierarchy a
little bit. So we've got our

472
00:32:23,400 --> 00:32:27,150
leaf state. And then you can
have these containers. These are

473
00:32:27,150 --> 00:32:30,840
like levels of hierarchy, which
we have shorthand for, which

474
00:32:30,840 --> 00:32:34,380
I'll go into right now. So the
first level of hierarchy we

475
00:32:34,380 --> 00:32:39,390
refer to as super states. The
next level we refer to as mode

476
00:32:39,390 --> 00:32:42,240
states. There's no difference,

477
00:32:42,450 --> 00:32:45,180
Audrow Nash: per se, it's just
because it's a hierarchy. So

478
00:32:45,180 --> 00:32:48,420
super states is like high level
control. And that's like

479
00:32:48,420 --> 00:32:51,660
fundamentally what the robot is
doing. It's mapping it's driving

480
00:32:51,660 --> 00:32:52,740
to some location.

481
00:32:54,030 --> 00:32:57,990
Brett Aldrich: In your
application, I think I think the

482
00:32:57,990 --> 00:33:03,060
most common use for for Super
states is for loops, for loops,

483
00:33:03,060 --> 00:33:10,530
or like, like sequences, you
know. So in that application, it

484
00:33:10,530 --> 00:33:14,850
moves to the first global
waypoint. Okay, it's to execute

485
00:33:14,910 --> 00:33:20,550
a super state, that is a radial
pattern. And you can set the

486
00:33:20,550 --> 00:33:23,850
parameters of that radial
pattern in the superstate. So I

487
00:33:23,850 --> 00:33:27,090
think in the video, it showed
something like 16 rays,

488
00:33:29,280 --> 00:33:32,490
Audrow Nash: and the 360 divided
by 16. And then it just went out

489
00:33:32,760 --> 00:33:34,260
exactly what each of those
angles,

490
00:33:34,290 --> 00:33:36,150
Brett Aldrich: okay, but you
would just go in there, and

491
00:33:36,150 --> 00:33:40,020
let's say, put in 32. And so
it's parameterised.

492
00:33:40,109 --> 00:33:45,569
Exactly, exactly. It does three
of those super states in a row,

493
00:33:46,019 --> 00:33:49,409
at which point it navigates to a
fourth way point, and we haven't

494
00:33:49,499 --> 00:33:55,589
execute an F pattern, same kind
of thing, although it's like, I

495
00:33:55,589 --> 00:33:58,349
think it's a series of seven
states that execute this

496
00:33:58,349 --> 00:34:01,079
repetitive F pattern. Again,
though, designed for floor

497
00:34:01,079 --> 00:34:06,299
coverage. Then it goes to a
final waypoint where it's more

498
00:34:06,299 --> 00:34:17,639
of an S shaped pattern. So five
total super states and five

499
00:34:17,639 --> 00:34:22,049
global way points, all the super
states parameterised. In this

500
00:34:22,049 --> 00:34:25,229
case, we're only using two or
thought well, let me think there

501
00:34:25,229 --> 00:34:27,569
might be more than one
orthogonal in there. But in

502
00:34:27,569 --> 00:34:30,179
terms of like the crucial
orthogonal for that example,

503
00:34:30,209 --> 00:34:38,579
there's two, there's the, the
the LiDAR, and to cool. Yeah, in

504
00:34:38,579 --> 00:34:40,079
that particular example,

505
00:34:40,620 --> 00:34:43,860
Audrow Nash: and nav to handling
the navigation of the robot from

506
00:34:43,860 --> 00:34:47,460
one spot to another, okay, and
controlling the motors and

507
00:34:47,460 --> 00:34:50,970
everything to drive it around.
Exactly, right. Okay.

508
00:34:51,089 --> 00:34:54,239
Brett Aldrich: Yep. Yep. In
other in other state machines,

509
00:34:54,239 --> 00:34:58,529
we might use, you know,
something like Ross to control

510
00:34:58,559 --> 00:35:01,439
the same kind of a similar way
that that move it relies on Ross

511
00:35:01,439 --> 00:35:04,559
to control the move the robot.
And we've had we've built

512
00:35:04,559 --> 00:35:08,849
examples and navigation in Ross,
one where it uses the Ross two

513
00:35:08,939 --> 00:35:12,179
or the Ross control draft
controller. But yeah, it's you

514
00:35:12,179 --> 00:35:15,749
know, you start using like your
standard Ross stack to get

515
00:35:15,749 --> 00:35:16,529
around. Yeah.

516
00:35:16,560 --> 00:35:20,010
Audrow Nash: And then so if
we're in superstate one we're in

517
00:35:20,010 --> 00:35:26,580
the radial star. Okay, one. What
does that look like from the

518
00:35:26,580 --> 00:35:29,880
mode states, so not the super
states, but now we're in Super

519
00:35:29,880 --> 00:35:33,090
state one. And so super state
one is composed of mode states,

520
00:35:34,230 --> 00:35:38,220
as you were saying, with the
shorthand, yeah. So how does it

521
00:35:38,220 --> 00:35:42,750
look? They're like, what, what's
going on down there? And how do

522
00:35:42,750 --> 00:35:44,070
we get closer to

523
00:35:44,970 --> 00:35:48,120
Brett Aldrich: the CLI that
example? Like, in depth, or just

524
00:35:48,120 --> 00:35:51,870
ballpark? Yeah, I believe the
way it has is that we've got a

525
00:35:51,870 --> 00:35:55,500
mode state called Run, and we
have another one called recover.

526
00:35:56,280 --> 00:36:03,690
And where I see that
architecture evolving, in going,

527
00:36:03,690 --> 00:36:07,920
you know, in terms of real world
is that one of the things that

528
00:36:07,920 --> 00:36:12,750
SMAC offers is very advanced
recovery sequences, and

529
00:36:12,750 --> 00:36:18,270
capabilities. So I imagined, and
I think one of the things that

530
00:36:18,270 --> 00:36:24,360
SMAC one of the most important
things that SMAC offers and in

531
00:36:25,020 --> 00:36:31,590
why it's disruptive, is that it
allows for a new order of

532
00:36:31,590 --> 00:36:35,340
magnitude in the complexity of
robotic missions, particularly

533
00:36:35,670 --> 00:36:39,120
age missions. So So for
instance, let's let's take an

534
00:36:39,120 --> 00:36:44,430
example of a fixed wing
aircraft, right. So you'd have

535
00:36:44,430 --> 00:36:49,890
one mode for taxing on the
runway, another mode or takeoff,

536
00:36:50,160 --> 00:36:52,650
another mode for I don't know,
you know, the your initial

537
00:36:52,650 --> 00:36:54,750
flight, where you're finding
your right heading, stuff like

538
00:36:54,750 --> 00:36:58,620
that. And for each one of those
modes, you're probably going to

539
00:36:58,620 --> 00:37:02,340
want to have a separate recovery
state, you know, separate

540
00:37:02,340 --> 00:37:07,950
recovery mode state, where
dependent, so let's say you're

541
00:37:07,950 --> 00:37:11,220
in takeoff, right, and something
wrong happens, then you switch

542
00:37:11,220 --> 00:37:12,240
from that mode.

543
00:37:13,170 --> 00:37:15,720
Audrow Nash: So the appropriate
recovery for that will take

544
00:37:15,720 --> 00:37:20,250
Brett Aldrich: off recovery, and
you begin your, your, you know,

545
00:37:20,250 --> 00:37:26,940
error recovery procedures there.
And as that continues to expand,

546
00:37:27,930 --> 00:37:30,630
you just, you end up with like
greater, greater needs of

547
00:37:30,630 --> 00:37:34,830
hierarchy. It also brings in the
question of where your data

548
00:37:34,830 --> 00:37:39,180
goes, another unique feature of
SMAC is that every state is a

549
00:37:39,180 --> 00:37:43,620
class and every container is a
class. So you can scope your

550
00:37:43,620 --> 00:37:46,920
variables and other things to
the lifetime. And that's needed.

551
00:37:47,490 --> 00:37:51,780
You know, perhaps you need a
variable across every state in

552
00:37:51,810 --> 00:37:55,080
in a certain mode. Perfect, you
put it in the mode, you can also

553
00:37:55,080 --> 00:37:57,960
do you we also have the
opportunity, or the option of

554
00:37:57,960 --> 00:37:59,670
global variables. But

555
00:38:01,320 --> 00:38:07,230
Audrow Nash: yeah, okay. So
interesting. And so, can you

556
00:38:07,230 --> 00:38:14,610
tell me a bit more about the
real? So you're saying, I guess,

557
00:38:14,610 --> 00:38:21,090
the origins of smack and how it
was born, from, I guess, a real

558
00:38:21,090 --> 00:38:24,750
application and then how it's
evolved since? Yeah,

559
00:38:25,230 --> 00:38:28,230
Brett Aldrich: it's in the
oranges of smack it's hard for

560
00:38:28,230 --> 00:38:36,330
me to put a finger on it i i
would say it started the same.

561
00:38:36,750 --> 00:38:42,360
So I graduated from UCLA with a
degree in biochemistry. And one

562
00:38:42,360 --> 00:38:47,550
of the the, my first job outside
of outside of university was

563
00:38:47,550 --> 00:38:54,000
under a NASA grant at the UCLA
UCLA Medical Center in the

564
00:38:54,000 --> 00:38:56,310
department of Head and Neck
Surgery under a brilliant

565
00:38:56,940 --> 00:39:03,270
researcher named Dr. Larry
Hoffman. And I, I ran one of the

566
00:39:03,270 --> 00:39:07,620
research labs there. I forget
the exact title, but that one of

567
00:39:07,620 --> 00:39:14,220
the labs was basically mine. And
what we were doing was it was

568
00:39:14,220 --> 00:39:19,560
this insane program where we
were dissecting the inner ears

569
00:39:19,680 --> 00:39:24,090
of we were, we were injecting,
like dyes, and then dissecting

570
00:39:24,090 --> 00:39:29,430
the inner ears of mammals,
mainly chinchillas and mice. And

571
00:39:29,430 --> 00:39:32,010
then we were studying the
organelles of the inner ear, the

572
00:39:32,010 --> 00:39:34,380
you trickle and the sack you
will and stuff like this.

573
00:39:34,740 --> 00:39:37,320
Audrow Nash: I don't know
anything about this. Okay. It's

574
00:39:37,800 --> 00:39:41,550
just an our little parts of the
object. Yeah,

575
00:39:41,610 --> 00:39:47,400
Brett Aldrich: even then. And in
dissecting these organelles, we

576
00:39:47,400 --> 00:39:51,480
would then visualize them, you
know, under fluorescent

577
00:39:51,480 --> 00:39:56,850
microscopes, and imagine like,
I'm holding up for the listening

578
00:39:56,850 --> 00:40:00,180
audience. I'm holding up like my
hand, it's like an Organon. It's

579
00:40:00,180 --> 00:40:03,480
like they would, they would have
these Nerf patterns that would

580
00:40:03,480 --> 00:40:07,350
kind of follow through these
organelles. And we were studying

581
00:40:07,350 --> 00:40:12,120
those in an effort to create
better rocket guidance systems,

582
00:40:12,120 --> 00:40:19,500
which I have no idea if it ever,
you know, resulted in such

583
00:40:19,500 --> 00:40:22,290
things, I have a feeling
gyroscopes do a pretty good job.

584
00:40:22,650 --> 00:40:25,890
But it got me it brought up.

585
00:40:25,890 --> 00:40:31,050
Audrow Nash: So it was this this
was like, fundamental. So like,

586
00:40:31,080 --> 00:40:35,400
one thing that might be similar
is I think it's rapid random

587
00:40:35,400 --> 00:40:39,780
exploring trees, R R T, or
something like this. Yeah. So

588
00:40:39,960 --> 00:40:43,830
it's, it's almost like an you're
trying to identify an algorithm

589
00:40:43,830 --> 00:40:47,700
that controls these nerves
spreading through them. And then

590
00:40:47,700 --> 00:40:51,330
maybe that algorithm would be
useful in applications, like,

591
00:40:51,540 --> 00:40:53,370
guided missiles, or whatever it
might have been.

592
00:40:53,850 --> 00:40:57,300
Brett Aldrich: Yep, that's
exactly right. And that's, and

593
00:40:57,300 --> 00:41:03,900
so it opened, expose me to to
concepts like this. neural nets

594
00:41:04,200 --> 00:41:08,610
was talked about. I got to
program a little bit of Fortran.

595
00:41:09,420 --> 00:41:18,120
Also, decision trees were part
of that. And it, it, it began an

596
00:41:18,120 --> 00:41:21,300
interest that I had, like, even
in terms of office hours, where

597
00:41:21,300 --> 00:41:24,810
I just started, I started
sketching out these kinds of

598
00:41:24,810 --> 00:41:29,100
systems, you know, like, and
then, in looking back on it, it

599
00:41:29,100 --> 00:41:31,140
was clear to me that I was
drawing out state machines,

600
00:41:31,140 --> 00:41:35,160
although my early my earliest
state machines, it's like, each

601
00:41:35,160 --> 00:41:37,980
state was a neuron. And so I was
imagining these chains of

602
00:41:37,980 --> 00:41:41,280
neurons and how they would
process information. And you

603
00:41:41,280 --> 00:41:46,920
know, what, where that was just
like, yeah. And so anyway, that

604
00:41:46,920 --> 00:41:51,060
was, that was where, like, some
of my earliest interest in that

605
00:41:51,360 --> 00:41:56,760
arose. Later, I went, I went
back to school to get a degree

606
00:41:56,790 --> 00:42:00,060
in math and theoretical computer
science at the University of

607
00:42:00,060 --> 00:42:05,820
Irvine, and which I did not
complete. But in some of the

608
00:42:05,820 --> 00:42:10,050
early courses, you know, I was
exposed to set theory automata

609
00:42:10,050 --> 00:42:12,060
theory. And so I had

610
00:42:13,080 --> 00:42:16,170
Audrow Nash: no, any idea what
that latter one is. Oh, automata

611
00:42:16,170 --> 00:42:18,870
Brett Aldrich: theory. That's
like, that's like the, that's

612
00:42:18,870 --> 00:42:24,330
like the math behind things like
finite state machines. Okay.

613
00:42:24,660 --> 00:42:29,520
Yeah. You get there into like,
whether or not state machines

614
00:42:29,520 --> 00:42:31,980
are Turing complete stuff, like

615
00:42:32,910 --> 00:42:35,430
Audrow Nash: proving things
about them. Theoretically. Yeah,

616
00:42:35,520 --> 00:42:37,410
Brett Aldrich: exactly.
Particularly when you start

617
00:42:37,410 --> 00:42:41,670
getting into advanced state
machines with event queues. You

618
00:42:41,670 --> 00:42:46,770
know, and like, how then how
that maps so there was that that

619
00:42:46,770 --> 00:42:54,690
part as well. I moving on later,
I remember I got there was a

620
00:42:54,720 --> 00:43:00,330
when I started believing that
robotics was the next wave that

621
00:43:00,330 --> 00:43:05,460
it was in I believe this still
that robotics is going to be the

622
00:43:05,460 --> 00:43:11,010
next boo and probably the
biggest one in my lifetime. I

623
00:43:11,010 --> 00:43:15,090
feel like that's going to happen
to within the next 10 years. And

624
00:43:15,390 --> 00:43:18,750
so as I was looking forward to
that there was a book called UML

625
00:43:18,750 --> 00:43:24,150
of real time systems and I read
that book like I I've gotten rid

626
00:43:24,150 --> 00:43:27,360
of it since but I don't know I
could almost pry tell you on a

627
00:43:27,360 --> 00:43:32,910
particular page what's on it and
sketching too at that time

628
00:43:32,910 --> 00:43:37,500
though, I although I was so
interested in them I never would

629
00:43:37,500 --> 00:43:41,670
have thought that I could have
written the state machine

630
00:43:41,670 --> 00:43:45,750
library like that I just I would
have thought that well and at

631
00:43:45,750 --> 00:43:48,780
this time this is really before
Ross you know so like the

632
00:43:48,780 --> 00:43:51,390
systems were more closed off I
would have thought that that was

633
00:43:51,480 --> 00:43:57,930
part of some giant proprietary
stack I see Yeah. Anyway my my

634
00:43:57,930 --> 00:44:03,720
first project you know that
involved Ross was creating what

635
00:44:03,870 --> 00:44:09,000
the company is real robotics and
we were creating level line

636
00:44:09,000 --> 00:44:12,150
cable reels that we're going to
provide mobile robots with

637
00:44:12,150 --> 00:44:15,930
tethered AC power for which you
know more

638
00:44:17,160 --> 00:44:19,380
Audrow Nash: level line which is
level one okay?

639
00:44:19,590 --> 00:44:23,790
Brett Aldrich: It's a level wind
meaning level wind level meaning

640
00:44:23,790 --> 00:44:28,860
that if we've got a real here it
goes like a fishing exactly like

641
00:44:28,860 --> 00:44:31,680
a fishing line fish yeah,
there's like a goes like this.

642
00:44:31,680 --> 00:44:35,580
So it winds perfectly every
time. Cool. And I've got a

643
00:44:35,580 --> 00:44:39,960
picture too of like what, what
we had in mind for the system

644
00:44:45,600 --> 00:44:48,930
holding it up for the camera
right now and it's on top of

645
00:44:49,470 --> 00:44:56,130
ClearPath robotics Ridgeback
robot so you can see the box

646
00:44:56,130 --> 00:45:01,620
that it is the real there's a
yellow it's meant to be Like a

647
00:45:01,650 --> 00:45:05,700
nine gallon Shopback that goes
on top in this application here,

648
00:45:05,700 --> 00:45:06,900
I'll show it from another angle.

649
00:45:11,429 --> 00:45:16,739
Audrow Nash: Okay, so it's, it
just looks like. So it looks

650
00:45:16,739 --> 00:45:20,219
like one of those small clear
paths, or maybe not small, one

651
00:45:20,219 --> 00:45:22,829
of those clear path robots that
has kind of the wheels

652
00:45:22,829 --> 00:45:26,099
underneath. And then there's a
big cube on top of it, and it

653
00:45:26,099 --> 00:45:29,069
kind of looks like there's so I
guess that's the Shopback

654
00:45:29,429 --> 00:45:31,379
cylinder that sticks out of the
cube.

655
00:45:31,409 --> 00:45:38,609
Brett Aldrich: Yeah, exactly,
exactly. Okay. And that's

656
00:45:39,600 --> 00:45:42,810
Audrow Nash: to get started with
this. So the problem was to do

657
00:45:43,440 --> 00:45:47,310
level cabling. So you wanted to
basically have the robot drive,

658
00:45:47,310 --> 00:45:50,130
and it would leave a cable
behind it. And then you could

659
00:45:50,220 --> 00:45:55,380
wind back on the same path, and
it would organize that cable as

660
00:45:55,380 --> 00:45:57,510
it retracted it, basically,

661
00:45:58,050 --> 00:46:00,720
Brett Aldrich: which, which
required tight coordination with

662
00:46:00,720 --> 00:46:05,910
navigation. And, and then also
tight coordination with what

663
00:46:05,910 --> 00:46:10,830
would be really the state
machine of whatever the plan was

664
00:46:10,830 --> 00:46:16,350
to basically sell those to, to
OEMs. You know, and so we knew

665
00:46:16,500 --> 00:46:18,570
Audrow Nash: that OEM is
original equipment

666
00:46:18,570 --> 00:46:21,720
manufacturers. So let's say so
that's like,

667
00:46:22,200 --> 00:46:25,410
Brett Aldrich: yeah, go ahead.
Well, yeah, somebody like Dyson

668
00:46:25,410 --> 00:46:28,740
vacuum or something, you know,
more probably more industrial,

669
00:46:28,740 --> 00:46:31,470
something like 10 internal
fills, but But yeah,

670
00:46:31,500 --> 00:46:33,810
Audrow Nash: whoever was going
to meet or know them, but I see.

671
00:46:34,080 --> 00:46:34,530
Yeah.

672
00:46:35,490 --> 00:46:39,000
Brett Aldrich: And so we knew
that we were going to so we

673
00:46:39,000 --> 00:46:42,150
built, you know, we started with
that software stack. And we

674
00:46:42,150 --> 00:46:44,460
moved all the way up. And we
really did some beautiful work

675
00:46:44,460 --> 00:46:49,770
there. Some notable people to
contributed on that project,

676
00:46:49,800 --> 00:46:55,620
Dave Coleman wrote something Oh,
project. Yep. Yeah. He was this

677
00:46:55,620 --> 00:46:59,460
was before picnic, he was a
graduate student at University

678
00:46:59,460 --> 00:47:03,060
of Colorado Boulder, and he
wrote some of the original Ross

679
00:47:03,060 --> 00:47:08,760
control code. Vince Magyar, also
worked on the project. He's the

680
00:47:08,790 --> 00:47:14,550
maintainer of Ross to control. A
mathematician by the name of ROB

681
00:47:14,550 --> 00:47:19,680
Hanna from UCLA. And I did some,
we mapped out all the

682
00:47:19,680 --> 00:47:23,550
mathematics where, imagine that
level line system, you know, the

683
00:47:23,550 --> 00:47:28,020
goal is to know exactly how much
cord is being produced with

684
00:47:28,020 --> 00:47:30,870
every encoder tick, but it's
changing all the time, depending

685
00:47:30,870 --> 00:47:35,940
on how many, you know, layers of
cord are on the real position of

686
00:47:35,940 --> 00:47:40,260
the level line carriage where
the robot is the robot rotating.

687
00:47:41,460 --> 00:47:48,090
And so we did all that. I
focused on the microcontroller

688
00:47:48,090 --> 00:47:51,450
code mainly. And that's kind of
how I that that was more my

689
00:47:51,450 --> 00:47:55,350
background is I came into smack
I was more like an embedded

690
00:47:55,350 --> 00:47:59,910
programmer. And that time, I
thought that C 99.

691
00:48:01,980 --> 00:48:03,120
Audrow Nash: That's where it's
at. Yeah.

692
00:48:03,660 --> 00:48:05,970
Brett Aldrich: That was my
belief in anything involving

693
00:48:05,970 --> 00:48:10,500
templates. I looked it like, you
know, I didn't like that at all.

694
00:48:11,190 --> 00:48:15,240
Yeah, Pablo country project too.
And there was also a developer,

695
00:48:16,260 --> 00:48:19,620
from the former ClearPath
developer named Devin Nash, he

696
00:48:19,620 --> 00:48:21,390
did some really great work on
the project, too.

697
00:48:22,740 --> 00:48:26,040
Audrow Nash: Anyway, it's cool
to see. It's funny to me that

698
00:48:26,040 --> 00:48:29,460
it's such a small community, in
a sense, as in these names keep

699
00:48:29,460 --> 00:48:33,630
popping up for a lot of
endeavors. Okay, so you worked

700
00:48:33,630 --> 00:48:38,520
on this robot. And so this was
with real robotics. And this was

701
00:48:38,520 --> 00:48:43,230
the application. Yep. And smack
was born from this.

702
00:48:43,500 --> 00:48:45,090
Brett Aldrich: Correct? Yeah.
Because we knew that we were

703
00:48:45,090 --> 00:48:50,580
going to have to integrate with
whatever the OEMs were using for

704
00:48:50,580 --> 00:48:53,610
their top level coordination,
because you have to coordinate

705
00:48:55,170 --> 00:48:58,800
you'd have to coordinate the
movements of the reel with the

706
00:48:58,800 --> 00:49:03,030
navigation, you know, the
navigation of the robot, which

707
00:49:03,030 --> 00:49:05,100
we accepted. You know, we knew
we were going to have to do

708
00:49:05,100 --> 00:49:09,780
custom work like that. But in
order to, you know, develop our

709
00:49:09,780 --> 00:49:14,280
own demos, the idea of a state
machine came in, also early on,

710
00:49:14,340 --> 00:49:20,190
I'm going to say so we started
this in like 2015 2014 2015 by

711
00:49:20,220 --> 00:49:26,280
2016, maybe even a little
earlier, I realized that smash

712
00:49:26,310 --> 00:49:27,960
was not up to the task,

713
00:49:28,200 --> 00:49:31,440
Audrow Nash: and smash what
Smash is that a filmer?

714
00:49:31,440 --> 00:49:35,070
Brett Aldrich: Oh, yes. Smash
was smashed was a state machine

715
00:49:35,070 --> 00:49:39,210
library developed by Jonathan
Bullrun, I believe in 2009. And

716
00:49:39,210 --> 00:49:43,920
it was a state machine that that
powered the PR two examples.

717
00:49:45,330 --> 00:49:50,580
Yeah. I think very highly of
that library. I think he did a

718
00:49:50,580 --> 00:49:56,400
number of very, very innovative
things that that inspired SMAC

719
00:49:57,360 --> 00:50:05,580
probably the most important was
Tying the events to actions, you

720
00:50:05,580 --> 00:50:08,340
know, like, like, like, like in
the example you were describing

721
00:50:08,340 --> 00:50:12,420
to navigation finally gets to a
goal that, you know, that then

722
00:50:12,420 --> 00:50:14,550
creates an event and you
transition to the next state.

723
00:50:14,610 --> 00:50:18,810
Exactly. There were things
though about smash that never

724
00:50:18,810 --> 00:50:24,810
fully. So I want to give credit
to Jonathan Boren like for like,

725
00:50:25,530 --> 00:50:29,430
it was a, it was a creative and
in essence a leap forward. I

726
00:50:29,430 --> 00:50:32,940
think in terms of though, like,
it was never really suitable for

727
00:50:32,940 --> 00:50:37,710
like more of a production level
of robotics. The concurrency

728
00:50:37,710 --> 00:50:41,550
always had issues, the data
porting is another subtle

729
00:50:41,730 --> 00:50:45,450
problem. Anytime you see, in my
opinion, anytime you see data

730
00:50:45,450 --> 00:50:48,000
porting and state machines, run,

731
00:50:48,030 --> 00:50:49,770
Audrow Nash: I don't know, I
don't know what data hoarding

732
00:50:49,770 --> 00:50:51,270
is. Well,

733
00:50:51,510 --> 00:50:58,020
Brett Aldrich: it's in in Smash.
When you want it to provide

734
00:50:58,020 --> 00:51:04,140
hierarchy, right? It was, you
would put another smash state

735
00:51:04,140 --> 00:51:10,080
machine inside of a state
machine. It was like, yeah, it

736
00:51:10,080 --> 00:51:11,130
was like you have

737
00:51:11,130 --> 00:51:14,370
Audrow Nash: that. And then you
would forward state down or

738
00:51:14,370 --> 00:51:15,900
something or a well,

739
00:51:16,110 --> 00:51:18,090
Brett Aldrich: yes, he did. This
is where it starts to get

740
00:51:18,090 --> 00:51:22,050
interesting. And how you move
data around, it's a design

741
00:51:22,050 --> 00:51:25,890
patterns are common amongst
state machine libraries, where

742
00:51:25,890 --> 00:51:29,850
people try to do that. I think
it's fraught with, with

743
00:51:29,850 --> 00:51:33,570
problems, and usually in where
you're trying to move data

744
00:51:33,600 --> 00:51:37,620
around, you know, and where you
have to be explicit about where

745
00:51:37,620 --> 00:51:42,900
it goes, that doesn't really
scale. Anyway, after so late

746
00:51:42,900 --> 00:51:48,330
2015, or mid 2015, I'm looking
at Smash, and I know that it

747
00:51:48,330 --> 00:51:55,650
won't be the library that allows
us to you we can't use that one.

748
00:51:55,650 --> 00:51:59,700
And so I look, I looked at the
market, and I didn't see any

749
00:51:59,700 --> 00:52:03,510
competitors. And I I saw a
chance, you know where we could

750
00:52:04,290 --> 00:52:06,780
we could take a stab on writing
our own, I knew it was a

751
00:52:06,780 --> 00:52:12,540
daunting prospect. But I don't
know, I take risks every now and

752
00:52:12,540 --> 00:52:21,930
then. And and I I think I think
I fell in love with the idea. I

753
00:52:21,930 --> 00:52:25,680
think if I try to justify it in
terms of cold, hard business

754
00:52:25,680 --> 00:52:32,820
logic, it's sort of tough. But
but we set out that way. And you

755
00:52:32,820 --> 00:52:37,380
know, I started on it
architecting out what that

756
00:52:37,380 --> 00:52:42,540
solution would be where I would,
where I how I would piece that

757
00:52:42,540 --> 00:52:47,760
thing together. And I settled on
booth state sharp. Mainly one

758
00:52:47,760 --> 00:52:51,030
thing that helped me in that in
that in that stage was that I

759
00:52:51,030 --> 00:52:52,410
focused solely on

760
00:52:53,520 --> 00:52:55,290
Audrow Nash: the C++ library
booth.

761
00:52:55,980 --> 00:52:58,860
Brett Aldrich: Exactly. And it's
template metaprogramming based,

762
00:52:59,100 --> 00:52:59,790
which is

763
00:53:01,830 --> 00:53:04,890
Audrow Nash: what was the what's
it called? Again, the library to

764
00:53:04,890 --> 00:53:05,310
C

765
00:53:06,630 --> 00:53:08,580
Brett Aldrich: sharp state
chart.

766
00:53:09,300 --> 00:53:10,500
Audrow Nash: Charts. Oh, okay.

767
00:53:10,619 --> 00:53:16,709
Brett Aldrich: Exactly. And that
comes from David Harrell named

768
00:53:16,709 --> 00:53:20,699
his models of state machines
state charts. So,

769
00:53:20,850 --> 00:53:24,360
Audrow Nash: huh. Yeah. Yes, an
arm to it. Great.

770
00:53:24,930 --> 00:53:30,540
Brett Aldrich: And, and yeah,
over. So we started that in

771
00:53:30,540 --> 00:53:34,230
approximate we started coding it
in approximately 2017. Right at

772
00:53:34,230 --> 00:53:38,790
the end of 2017. Excuse me. But
I had been working on it for

773
00:53:38,790 --> 00:53:41,100
about a year at that point, just
like laying out the

774
00:53:41,100 --> 00:53:46,440
architecture. I use my
intuition, largely, but I got

775
00:53:46,440 --> 00:53:52,410
pretty good intuition. And
later, you know, as I learned

776
00:53:52,410 --> 00:53:55,020
more, I look back and I'm
surprised how many of the

777
00:53:55,020 --> 00:53:58,530
decisions we got, right. Nice.
Yeah.

778
00:54:00,240 --> 00:54:07,110
Audrow Nash: Okay, and so then
real, real robotics. closed down

779
00:54:07,140 --> 00:54:09,720
or No? Was this? Yeah, so

780
00:54:09,720 --> 00:54:13,830
Brett Aldrich: what 2017 We
began No, sorry, at the end of

781
00:54:13,830 --> 00:54:20,370
2017. We began building the
library. And very, very early,

782
00:54:20,730 --> 00:54:26,280
the market pull started to pull
us in. So that call with click

783
00:54:26,550 --> 00:54:33,780
here.com that took place, I
think in May of 2018. So it was

784
00:54:33,810 --> 00:54:36,450
as soon as we were developing
it, we started getting calls.

785
00:54:37,950 --> 00:54:42,360
Then, we started working with
gray orange. I'm going to say

786
00:54:42,360 --> 00:54:48,600
late 2018. So it's we started
just being pulled into you know,

787
00:54:48,600 --> 00:54:55,050
one meeting after another and,
and then two I picked up

788
00:54:55,050 --> 00:55:01,590
confidence as we proceeded. Yep.
Ran into So at that point, we

789
00:55:01,590 --> 00:55:07,170
were developing both with both
real robotics and smack, which

790
00:55:07,170 --> 00:55:10,230
later, we split off into Robo
soft, but at the same time, we

791
00:55:10,230 --> 00:55:16,230
were pursuing them at the same
time. That went all the way up

792
00:55:16,230 --> 00:55:20,550
until we announced the library
in 2020. In June of 2020, we

793
00:55:20,550 --> 00:55:27,480
announced, wow. Okay. And we set
out one to finish up the reel.

794
00:55:27,510 --> 00:55:31,470
And our plan was to launch them
together. And

795
00:55:34,830 --> 00:55:37,200
Audrow Nash: launch the real
launch what together both real

796
00:55:37,260 --> 00:55:42,180
and smack together, launch the
company real robotics. And with

797
00:55:42,750 --> 00:55:45,450
and smack at the same time I
see. Right? Yep.

798
00:55:45,630 --> 00:55:50,190
Brett Aldrich: And we ran into a
mechanical issue along the way.

799
00:55:50,190 --> 00:55:56,040
So we announced the we announced
smack for Ross, one in June. And

800
00:55:56,310 --> 00:55:59,640
we immediately set out to create
it for Ross too, because I

801
00:55:59,640 --> 00:56:03,900
realized that as we announced
the library, that, that at that

802
00:56:03,900 --> 00:56:10,350
point, most of the most of the
major players, were already

803
00:56:10,350 --> 00:56:14,220
moving into Ross, two. And so we
immediately set out another

804
00:56:14,220 --> 00:56:18,630
version, and also set out to
complete the reel, and where

805
00:56:18,630 --> 00:56:23,070
it's at now, the real works, we
got a picture to have it like we

806
00:56:23,280 --> 00:56:27,570
and we built this thing. It's
awesome. And there's one

807
00:56:27,570 --> 00:56:35,640
mechanical issue. And but the
the market poll was just too

808
00:56:35,640 --> 00:56:39,630
great. And so I'm putting it
down for a while and putting all

809
00:56:39,630 --> 00:56:45,030
of my focus on smack now. So you
need to figure idea, you know,

810
00:56:45,060 --> 00:56:49,590
Audrow Nash: so think, by market
poll, your meaning that there

811
00:56:49,590 --> 00:56:53,850
was so much customer demand,
that it kind of sucked you away

812
00:56:53,850 --> 00:56:57,720
from real robotics. Yeah, um,
suck the time and energy. Okay.

813
00:56:57,900 --> 00:57:04,740
Yeah. So then, what do you
think? So? what is the what is

814
00:57:04,740 --> 00:57:09,090
the appeal of smack to these
companies wire? Like, what are

815
00:57:09,090 --> 00:57:15,420
they looking for that smack is
meeting? And why does it not?

816
00:57:16,290 --> 00:57:18,750
Why why are there not
alternatives? And I don't know

817
00:57:18,750 --> 00:57:21,990
what, what why is smack so
appealing to them? Basically,

818
00:57:22,019 --> 00:57:23,969
Brett Aldrich: I think I think
the first part is that you've

819
00:57:23,969 --> 00:57:28,319
got a standardization at the
application development layer,

820
00:57:28,739 --> 00:57:30,959
you know, smack can be viewed as
basically an Application

821
00:57:30,959 --> 00:57:33,719
Development Framework. So I
think that's, I think that's

822
00:57:33,899 --> 00:57:40,649
what draws them. I think the
features of Smak then start to

823
00:57:40,949 --> 00:57:45,569
come into play. And the main or
I'll try to go through a few

824
00:57:45,569 --> 00:57:51,749
important ones. One of which is
that being a composite, smack.

825
00:57:52,889 --> 00:57:56,699
With smack, you can build state
machines that are an order of

826
00:57:56,699 --> 00:58:00,689
magnitude more complicated than
with almost any other library.

827
00:58:02,819 --> 00:58:05,909
The reason for this is the
compile time validation. This

828
00:58:05,909 --> 00:58:09,659
comes from boost state chart. So
have you ever heard of the N

829
00:58:09,659 --> 00:58:12,569
times N problem in state
machine?

830
00:58:13,290 --> 00:58:16,440
Audrow Nash: Not I don't know
what it is in state machines. So

831
00:58:16,470 --> 00:58:19,710
Brett Aldrich: it's, you know,
I, it becomes intractable note,

832
00:58:20,100 --> 00:58:24,540
that when you have when you have
n states, right, then you might

833
00:58:24,540 --> 00:58:25,020
need

834
00:58:26,310 --> 00:58:27,300
Audrow Nash: and transition the

835
00:58:27,300 --> 00:58:30,180
Brett Aldrich: transitions,
yeah, to each state. And so it

836
00:58:30,180 --> 00:58:32,370
just keeps getting bigger and
bigger. You know, like, if

837
00:58:32,370 --> 00:58:35,550
you've only got five states,
okay, great. You got n times n

838
00:58:35,550 --> 00:58:39,930
is 25. But what happens when you
have 20? States? 30 states?

839
00:58:40,680 --> 00:58:48,930
Yeah, that expansion. And this,
I don't like I feel like the the

840
00:58:48,930 --> 00:58:53,910
academic treatment of the N
times N problem is overly

841
00:58:53,910 --> 00:58:57,060
simplistic and misguided. But,
but there

842
00:58:57,060 --> 00:58:59,250
Audrow Nash: isn't, it might be
just more theoretical, and it

843
00:58:59,250 --> 00:59:05,160
might miss some of the
application. considerations and

844
00:59:05,160 --> 00:59:05,850
application.

845
00:59:06,059 --> 00:59:09,119
Brett Aldrich: It's true. I
will. And I also think it it's

846
00:59:09,119 --> 00:59:14,729
somewhat sloppy, versus it seems
like big O notation, but without

847
00:59:14,729 --> 00:59:21,659
the without the rigor, I'd say.
But anyway, but it is true that

848
00:59:21,659 --> 00:59:25,709
the larger your state machine
gets, the harder it is to, you

849
00:59:25,709 --> 00:59:29,399
know, to manage that, or at
least it can be. And yeah, and

850
00:59:29,399 --> 00:59:34,739
this also gets into one
criticism of state machines is

851
00:59:34,739 --> 00:59:38,759
that they're a one way transfer
of control. Right, like so when

852
00:59:38,759 --> 00:59:41,729
you go from one state to
another. It's this you don't you

853
00:59:41,729 --> 00:59:44,189
don't automatically go back to
the state you were in currently.

854
00:59:44,459 --> 00:59:47,489
And in that sense, they've been
compared to go to statements.

855
00:59:48,330 --> 00:59:50,160
Audrow Nash: Okay, so I'm just
jumping around

856
00:59:50,430 --> 00:59:53,910
Brett Aldrich: where you jump
around. And while I think that's

857
00:59:54,270 --> 00:59:57,690
a bit of a stretch, there's a
truth that if you go to the

858
00:59:57,690 --> 01:00:01,710
wrong place, then you're in big
Trouble, right? If the if you if

859
01:00:01,710 --> 01:00:05,040
you're transitioning to a state
and there is no state there, you

860
01:00:05,040 --> 01:00:05,520
know, we got an

861
01:00:06,210 --> 01:00:08,220
Audrow Nash: undefined. Yep.
Right.

862
01:00:08,370 --> 01:00:15,150
Brett Aldrich: But what happened
there is? So template

863
01:00:15,150 --> 01:00:17,220
metaprogramming arose, so

864
01:00:17,220 --> 01:00:19,290
Audrow Nash: does that. What
does that mean? Yeah.

865
01:00:20,610 --> 01:00:21,630
Brett Aldrich: So um,

866
01:00:23,370 --> 01:00:26,520
Audrow Nash: so I'm familiar
with templating and C++, Is it

867
01:00:26,520 --> 01:00:27,360
anything similar?

868
01:00:27,390 --> 01:00:29,340
Brett Aldrich: It's very
similar. It's the same. It's the

869
01:00:29,340 --> 01:00:30,180
same type of

870
01:00:30,900 --> 01:00:33,030
Audrow Nash: and Meta
Programming. Is it like lists?

871
01:00:33,630 --> 01:00:40,050
Like programming? And less is?
That's what, but okay, what is

872
01:00:40,050 --> 01:00:41,310
that's a beautiful thing that
happens

873
01:00:41,310 --> 01:00:44,070
Brett Aldrich: it, it happens at
compile time. That's the key

874
01:00:44,070 --> 01:00:48,480
thing is that, like, so?
Template metaprogramming by

875
01:00:48,480 --> 01:00:53,850
occurring at compile time. It's
what sets it apart. And

876
01:00:55,290 --> 01:00:57,090
Audrow Nash: because you can
have all sorts of compiler

877
01:00:57,090 --> 01:01:00,690
checks, rather than runtime
checks or this kind of thing.

878
01:01:00,780 --> 01:01:05,400
No, that's okay. So because of
that, you just run into a

879
01:01:05,400 --> 01:01:08,880
compile and build and whatever.
And it's gonna go, and it's

880
01:01:08,880 --> 01:01:11,910
gonna suss out a bunch of
problems for you, rather than

881
01:01:11,910 --> 01:01:16,920
you having to like test them.
And see, so it's much faster and

882
01:01:16,920 --> 01:01:19,200
easier for the developer.

883
01:01:19,350 --> 01:01:21,960
Brett Aldrich: And that's right.
That's right. Much safer. That's

884
01:01:21,960 --> 01:01:22,170
right.

885
01:01:22,200 --> 01:01:24,480
Audrow Nash: So can I take a
stab at what template

886
01:01:24,480 --> 01:01:29,070
metaprogramming would mean,
because I. So I'm imagining it's

887
01:01:29,070 --> 01:01:31,920
similar to what they do in Lisp.
And I'm imagining it somewhat

888
01:01:31,920 --> 01:01:36,450
similar to what they do in C++.
So it would be that you're

889
01:01:36,510 --> 01:01:41,220
writing code, and your code at
compile time is going to like

890
01:01:41,220 --> 01:01:44,280
expand things, run them through
functions, and then it will

891
01:01:44,280 --> 01:01:48,930
change what that function does
based on arguments or this kind

892
01:01:48,930 --> 01:01:49,380
of thing.

893
01:01:49,680 --> 01:01:52,200
Brett Aldrich: Okay, that's more
like function templates. Yeah.

894
01:01:52,350 --> 01:01:56,670
But it's okay. Same thing,
right? How do I say that? In

895
01:01:56,670 --> 01:02:01,830
let's say, if you were if you
were starting to look into, like

896
01:02:01,830 --> 01:02:05,040
the template metaprogramming
that works in boost HRT, that

897
01:02:05,040 --> 01:02:08,640
would be like, the opening
chapter. You would, you'd start

898
01:02:08,640 --> 01:02:14,220
there. Yeah. But then it moves
into class templates. And okay,

899
01:02:14,430 --> 01:02:16,800
Audrow Nash: well, yeah. So you
can do all sorts of objects this

900
01:02:16,800 --> 01:02:19,650
way. I mean, you could do
functions, you could do classes,

901
01:02:19,650 --> 01:02:22,620
but it's fundamentally the same
kind of approach, where things

902
01:02:22,620 --> 01:02:25,470
are parameterised. And it's
generating stuff based on those

903
01:02:25,470 --> 01:02:29,820
parameters by following Yeah, by
following a code path that you

904
01:02:29,820 --> 01:02:33,510
define, which is the meta
template programming part of it,

905
01:02:33,540 --> 01:02:37,140
right? Yep, that's right.
Something like that. Yep. Okay.

906
01:02:37,590 --> 01:02:43,620
Brett Aldrich: And in the, like,
1995, there was a famous paper

907
01:02:43,620 --> 01:02:48,720
by James Copeland, where this
pattern called CRTP, and it

908
01:02:48,720 --> 01:02:51,840
stands for the curiously
recurring template pattern was

909
01:02:51,840 --> 01:02:56,670
discovered. And it was
discovered by independently by a

910
01:02:56,670 --> 01:03:00,120
few, but one of them was a
female programmer by the name of

911
01:03:00,120 --> 01:03:06,270
Lorraine jewel. And it's that
method was then taken by the

912
01:03:06,270 --> 01:03:08,520
developers of the boost
libraries. And a lot of people

913
01:03:08,550 --> 01:03:11,310
don't know this about the boost
libraries. But the boost

914
01:03:11,310 --> 01:03:15,540
libraries are all based on
template metaprogramming. David

915
01:03:15,540 --> 01:03:19,740
Abrams was the founder of the
boost libraries. And he wrote a

916
01:03:19,740 --> 01:03:23,940
library called MPL, so meta
programming metaprogramming

917
01:03:23,940 --> 01:03:31,200
library. And then, two important
state machine libraries emerged

918
01:03:31,230 --> 01:03:36,240
from that early periods of boost
was founded in 2002. Libraries

919
01:03:36,240 --> 01:03:40,500
boost MSM, which was written by
Christoph Henry, and then boost

920
01:03:40,500 --> 01:03:43,710
HR, which is written by Andreas
Huber, Donnie, and both of them

921
01:03:43,710 --> 01:03:51,000
use CRTP to validate the state
machines at compile time. And in

922
01:03:51,000 --> 01:03:53,760
in Andreas Huber, Donnie, is
implementation specifically,

923
01:03:54,450 --> 01:03:57,900
it's a game changer, because it
makes sure that you know, every

924
01:03:57,900 --> 01:04:01,140
transition has a source and
destination, make sure that

925
01:04:01,140 --> 01:04:05,190
every state has a parent and
state machine that it accounts

926
01:04:05,190 --> 01:04:05,580
for

927
01:04:05,820 --> 01:04:08,520
Audrow Nash: and a lot of
compile time safety, basically,

928
01:04:08,520 --> 01:04:10,860
because of these validations.
Okay, yes.

929
01:04:10,890 --> 01:04:15,840
Brett Aldrich: And I think too,
you get yet, one thing I've got

930
01:04:15,840 --> 01:04:18,600
is that it's very easy to run a
state machine library. The trick

931
01:04:18,600 --> 01:04:22,830
is making all the works. And,
and the fact that it's compiled

932
01:04:22,830 --> 01:04:27,360
every time you're compiling, you
know, you're getting checked. It

933
01:04:27,360 --> 01:04:33,420
just has a different different
type of reliability, a different

934
01:04:33,420 --> 01:04:38,430
type of, you know, reusability
and that's tied to that. Okay.

935
01:04:38,700 --> 01:04:45,420
Yeah. And hence, why I think
we're, you're able to, and that

936
01:04:45,450 --> 01:04:50,790
in combination with state local
storage is what allows blue

937
01:04:50,790 --> 01:04:57,360
state chart and through
inheritance SMAC to to have

938
01:04:57,360 --> 01:05:01,350
state machines that are orders
of now magnitude larger than

939
01:05:01,770 --> 01:05:04,020
what you would think if you
believed in the n times n

940
01:05:04,020 --> 01:05:08,310
program. For instance, in the
spec to repo today, there is a

941
01:05:08,310 --> 01:05:11,910
state machine known as SM
multistage one. I wrote the

942
01:05:11,910 --> 01:05:16,020
state machine, it has over 165
states and over 100 transitions.

943
01:05:16,770 --> 01:05:20,760
Wow. You know, that big deal?
Yeah. Like it wasn't that hard

944
01:05:20,760 --> 01:05:24,480
to write it didn't take that
long. And if you mess up

945
01:05:24,480 --> 01:05:26,370
anything, you know about it at
compile

946
01:05:26,370 --> 01:05:30,480
Audrow Nash: time? Yeah, that's
really nice. Yeah. Okay, what?

947
01:05:31,410 --> 01:05:35,550
So you mentioned all this
industry interest in why you

948
01:05:35,550 --> 01:05:39,390
mentioned all this interest in
SMAC? Can you tell me some of

949
01:05:39,390 --> 01:05:42,780
the types of projects that
you've been working on with it,

950
01:05:42,780 --> 01:05:47,220
or some of the types of
companies or the problem domains

951
01:05:47,250 --> 01:05:49,620
that the companies are
interested in solving with?

952
01:05:50,130 --> 01:05:50,850
Smack?

953
01:05:51,420 --> 01:05:54,030
Brett Aldrich: Hmm, trying to
think of like patterns across

954
01:05:54,030 --> 01:06:01,440
them? I think the main one that
has, has brought them at this

955
01:06:01,440 --> 01:06:06,660
stage, you know, to, to smack is
the problem of concurrency. You

956
01:06:06,660 --> 01:06:12,000
know, basically, how do you
control? And, you know, I think

957
01:06:12,000 --> 01:06:17,190
we would start with navigation,
and at least one arm and maybe

958
01:06:17,190 --> 01:06:21,300
two, and then a perception
system, and maybe a gripper, you

959
01:06:21,300 --> 01:06:25,260
know, just a some type of
minimal implementation like

960
01:06:25,260 --> 01:06:29,370
that, although, as we saw in the
field work robotics example, you

961
01:06:29,370 --> 01:06:36,480
know, quickly went to four.
Other Other ones, let's see,

962
01:06:36,750 --> 01:06:36,990
what

963
01:06:36,990 --> 01:06:39,330
Audrow Nash: kind of what kind
of domains or tasks are they

964
01:06:39,330 --> 01:06:45,450
trying to solve? Like, what is
the task that you can

965
01:06:45,450 --> 01:06:49,200
accomplish? Look like with this?
I suppose. Yeah.

966
01:06:49,410 --> 01:06:52,950
Brett Aldrich: One. So you know,
one was a, like a self driving

967
01:06:52,950 --> 01:06:56,280
car. Another it's it's broad.
It's broad. And yeah.

968
01:06:57,660 --> 01:07:06,120
Another one was with with gray,
orange, there's was a, it was a,

969
01:07:06,390 --> 01:07:12,900
it was a two armed robot with
two arms on a gantry that was in

970
01:07:12,900 --> 01:07:16,890
like a warehouse type context.
And I believe it was used for

971
01:07:16,890 --> 01:07:18,030
folding shirts.

972
01:07:19,440 --> 01:07:24,450
Yeah. So. But again, we have
multiple orthogonal, right, like

973
01:07:24,480 --> 01:07:29,730
multiple, you know, arms in one
application. And then for field

974
01:07:29,730 --> 01:07:34,860
work, robotics, you know, again,
like then the the, we have the

975
01:07:34,860 --> 01:07:41,010
expansion to multiple multiple
arms. I would say that that's

976
01:07:41,010 --> 01:07:48,480
probably at this stage, the most
important element is the the

977
01:07:48,480 --> 01:07:52,650
modularity that comes with
orthogonality. Areas that I

978
01:07:52,650 --> 01:07:58,230
don't think have been touched
yet, with Smak is the complexity

979
01:07:58,410 --> 01:08:02,100
that it can go to with the multi
stage missions. I'm not where

980
01:08:02,100 --> 01:08:04,470
Audrow Nash: you so where would
that go? What would be some

981
01:08:04,470 --> 01:08:07,530
problems that you could solve
that are kind of like, pushing

982
01:08:07,530 --> 01:08:09,450
it to its limits? And
complexity?

983
01:08:09,750 --> 01:08:14,340
Brett Aldrich: Hmm. Well, let's
see. See if I can think of

984
01:08:16,290 --> 01:08:19,380
Audrow Nash: would it be like
space related things? Okay.

985
01:08:19,380 --> 01:08:22,860
Brett Aldrich: Yeah, let me I'll
try to freestyle a space related

986
01:08:22,860 --> 01:08:27,420
mission. Um, you know, one thing
I've heard being talked about

987
01:08:27,810 --> 01:08:35,070
DARPA is where you can really
bring down the cost of launches,

988
01:08:35,310 --> 01:08:37,740
right? Well, let's say you've
got like some type of lat like

989
01:08:37,740 --> 01:08:43,260
some say, it's like a truck type
device, but it navigates out to

990
01:08:43,260 --> 01:08:46,380
somewhere on its own sets up a
launch pad and then launches

991
01:08:46,380 --> 01:08:53,220
into space, right? Transformer
in that sense, you know, so you

992
01:08:53,220 --> 01:08:57,960
could have one, one mode state,
that's for your driving portion.

993
01:09:00,270 --> 01:09:02,790
And you're going to need
different recovery procedures,

994
01:09:02,820 --> 01:09:03,510
you know, depending on

995
01:09:03,959 --> 01:09:05,549
Audrow Nash: driving everything,
yeah.

996
01:09:06,030 --> 01:09:11,550
Brett Aldrich: Then you go to
you transition to the launch

997
01:09:11,550 --> 01:09:16,200
area, setup, state, state. And,
you know, you're gonna have

998
01:09:16,200 --> 01:09:18,720
multiple sequences involved,
there are different recovery

999
01:09:18,720 --> 01:09:23,610
procedures, etc, etc. Finally,
the launch. And then, you know,

1000
01:09:23,610 --> 01:09:27,330
again, it changes. And in fact,
you're probably your orthogonal

1001
01:09:27,330 --> 01:09:30,300
is would change, right? Probably
like the physical subsystems

1002
01:09:30,300 --> 01:09:32,580
that you care about. And each
one of those contexts would

1003
01:09:32,610 --> 01:09:33,570
would be modified.

1004
01:09:35,250 --> 01:09:37,260
Audrow Nash: That's a cool
concept. It doesn't make sense.

1005
01:09:37,560 --> 01:09:40,890
Brett Aldrich: Yeah. And then to
you know, if that trucks got to

1006
01:09:40,890 --> 01:09:43,110
get out of there afterwards,
what if it has to, you know,

1007
01:09:43,140 --> 01:09:46,890
wants to launch and move on?
Yep, that would be another.

1008
01:09:47,370 --> 01:09:52,830
Another way. You just keep
changing on and on. And I do for

1009
01:09:52,830 --> 01:09:57,810
see. One, one bit of feedback
that we've gotten that I think

1010
01:09:57,810 --> 01:10:01,860
is important is that as people
We'll start to use events in

1011
01:10:01,860 --> 01:10:04,770
their programming, you start
having an explosion of events,

1012
01:10:04,800 --> 01:10:07,320
which is good, you know, but you
just want to handle them more.

1013
01:10:07,320 --> 01:10:12,570
And once you start using states
to chop up your problems, you

1014
01:10:12,570 --> 01:10:14,970
want more of them. I think
that's, that's another

1015
01:10:14,970 --> 01:10:17,730
interesting thing that smack
does it. If we look at it almost

1016
01:10:17,730 --> 01:10:21,450
from economic terms, it
dramatically lowers the costs of

1017
01:10:21,450 --> 01:10:24,840
creating states. Like, for
instance, one of the the

1018
01:10:24,870 --> 01:10:28,470
examples that I think it's sort
of striking is, you know, the

1019
01:10:28,470 --> 01:10:31,830
early 2000, for DARPA
challenges, right, where you're,

1020
01:10:31,830 --> 01:10:35,160
you're navigating across the
desert. And I feel that that's

1021
01:10:35,160 --> 01:10:41,100
still influences navigation,
like even to today. He's a star

1022
01:10:41,100 --> 01:10:43,170
planners and stuff like that,
that make these very

1023
01:10:43,170 --> 01:10:45,990
complicated, you know, plans,
it's almost, and

1024
01:10:45,990 --> 01:10:49,590
Audrow Nash: so just a little
background. So a star has kind

1025
01:10:49,590 --> 01:10:53,130
of an optimal planning algorithm
that'll go, and it has a

1026
01:10:53,130 --> 01:10:55,830
heuristic for how it proceeds.
But it goes, the goal is that

1027
01:10:55,830 --> 01:10:57,630
way, I'm gonna explore
everything towards that

1028
01:10:57,630 --> 01:11:01,980
direction. And when it arrives
at a solution, it computes the

1029
01:11:01,980 --> 01:11:06,420
optimal solution in the
environment. So it's a, that's

1030
01:11:06,420 --> 01:11:09,540
why it has the star. But okay,
so when you're doing path

1031
01:11:09,540 --> 01:11:11,640
planning, and you're using
something that can get an

1032
01:11:11,640 --> 01:11:15,420
optimal solution, this is as
compared to like, RRT, the rapid

1033
01:11:15,420 --> 01:11:19,170
random exploring trees, or
whatever it is, which finds an

1034
01:11:19,170 --> 01:11:22,860
approximate solution by kind of
branching, it's not optimal.

1035
01:11:23,100 --> 01:11:26,910
Brett Aldrich: Yeah. samples off
of it. Yep. Yeah.

1036
01:11:26,940 --> 01:11:29,730
Audrow Nash: I mean, you can use
that and then optimize from the

1037
01:11:29,730 --> 01:11:33,390
RT one. But okay, so you're
saying we a star for

1038
01:11:33,510 --> 01:11:34,620
exploration?

1039
01:11:35,850 --> 01:11:38,430
Brett Aldrich: Well, it sort of
as in my mind, the assumption

1040
01:11:38,460 --> 01:11:41,190
that there's only one state, you
know, that you've got to

1041
01:11:41,190 --> 01:11:45,750
navigate from here to Vegas, in
one state, maybe, maybe, right,

1042
01:11:45,780 --> 01:11:52,500
which is, um, and I think when
you start having like, readily

1043
01:11:52,500 --> 01:11:54,990
available state machine
libraries, where, you know,

1044
01:11:54,990 --> 01:11:58,200
developers are familiar with
them, you can all of a sudden

1045
01:11:58,200 --> 01:12:01,320
start using very different tools
to start, you know, chopping

1046
01:12:01,320 --> 01:12:02,130
that problem up.

1047
01:12:03,270 --> 01:12:08,040
Audrow Nash: Okay, so the basic
if you didn't have to, so if

1048
01:12:08,040 --> 01:12:11,400
it's complex, and you get your
trajectory from some planner,

1049
01:12:12,300 --> 01:12:14,850
the previous way of doing things
was you put everything in one

1050
01:12:14,850 --> 01:12:18,540
big state, and it's all very
complex to manage, because you

1051
01:12:18,540 --> 01:12:22,410
have to manage a lot of like
internal variables to figure out

1052
01:12:22,440 --> 01:12:26,880
how control should be handled.
And so if you can chop up the

1053
01:12:26,880 --> 01:12:30,990
state into small, clearly
defined problems, and you can

1054
01:12:30,990 --> 01:12:35,130
handle them very well. Because
you can only consider what you

1055
01:12:35,130 --> 01:12:41,820
need and have the like, you
basically only have the problem

1056
01:12:41,820 --> 01:12:46,740
parts that are required to solve
the problem. For that one

1057
01:12:46,740 --> 01:12:49,650
problem rather than everything
kind of mushed. Together.

1058
01:12:50,100 --> 01:12:53,010
Brett Aldrich: Yep. Yep. Okay,
that also has interesting

1059
01:12:53,010 --> 01:12:56,010
effects, you know, back to the
client libraries and stuff like

1060
01:12:56,010 --> 01:13:03,090
this. I, I think that one of the
ways, or one of the ways that I

1061
01:13:03,090 --> 01:13:07,500
hope it SMAC will influence Ross
in general, is that it will

1062
01:13:07,500 --> 01:13:12,060
bring down the size of the
servers and and make them more

1063
01:13:12,060 --> 01:13:15,390
manageable. So to give a little
context, what do you mean

1064
01:13:15,390 --> 01:13:22,110
servers? Sure. So let's look at
move it and enough to. So I'm

1065
01:13:22,110 --> 01:13:24,960
gonna throw out some statistics.
I don't know exactly how

1066
01:13:24,960 --> 01:13:26,790
accurate they are. I'm sure
there's people with more

1067
01:13:26,790 --> 01:13:31,050
accurate numbers. But I remember
speaking to Mike Loughton at a

1068
01:13:31,050 --> 01:13:35,700
picnic, and I'm sharing with me
that the move at code base was

1069
01:13:35,700 --> 01:13:40,590
something like over 100,000
lines of code. I get huge, huge.

1070
01:13:40,860 --> 01:13:48,990
And I also I have a tool that
attempts to tell me how many

1071
01:13:48,990 --> 01:13:51,480
lines of code are in something
and I ran it on nap two, and it

1072
01:13:51,480 --> 01:13:59,700
came back at 111,000. Okay, so
that's sort of shows like a

1073
01:13:59,700 --> 01:14:02,400
level of complexity in here. And
some of these like extremely

1074
01:14:02,400 --> 01:14:02,730
common.

1075
01:14:03,960 --> 01:14:06,630
Audrow Nash: Right, I see what
you're saying. Yeah. Because

1076
01:14:06,660 --> 01:14:09,330
because you can divide things
up. They don't have to get so

1077
01:14:09,330 --> 01:14:12,750
large. Yes, one. Yes. Okay.

1078
01:14:12,900 --> 01:14:15,540
Brett Aldrich: Much simpler
planners. Exactly. And that's

1079
01:14:15,540 --> 01:14:18,510
also important too, in that,
from our own experience of

1080
01:14:18,510 --> 01:14:22,590
developing examples, the place
that we really like you just

1081
01:14:22,590 --> 01:14:26,100
start burning developer hours,
is fiddling with the the

1082
01:14:26,100 --> 01:14:29,490
settings on these black box
planners and, and checking them

1083
01:14:29,490 --> 01:14:32,670
out during runtime and
simulation. Just, there's just a

1084
01:14:32,670 --> 01:14:39,240
slowness to it. And the way that
that everybody is generally

1085
01:14:39,240 --> 01:14:42,030
interacting with these is, okay,
so you write your own note,

1086
01:14:42,090 --> 01:14:44,760
write your own, which is
essentially like a client that's

1087
01:14:44,760 --> 01:14:48,450
going to interact with with nap
to let's say, and I don't know,

1088
01:14:48,450 --> 01:14:52,500
what would you say that they
started 60 lines of code, maybe

1089
01:14:52,500 --> 01:14:56,070
200. And then they, you know, we
start building out your

1090
01:14:56,070 --> 01:15:00,000
application, maybe it's like
1000 You know, at some point

1091
01:15:01,740 --> 01:15:04,830
Audrow Nash: So you're saying
1000 lines of code and relative

1092
01:15:04,830 --> 01:15:07,320
to all the way out to?

1093
01:15:07,950 --> 01:15:10,140
Brett Aldrich: Yeah, exactly.
That's a small thing interacting

1094
01:15:10,140 --> 01:15:12,810
with this massive, you know, we
it's like we put all the

1095
01:15:12,810 --> 01:15:19,920
complexity over in, in these
giant servers. Right now and

1096
01:15:19,920 --> 01:15:20,190
just

1097
01:15:20,190 --> 01:15:23,130
Audrow Nash: by by server, you
mean code base effectively?

1098
01:15:23,430 --> 01:15:27,090
Yeah, like we're referencing it
as a dependency in our code. And

1099
01:15:27,090 --> 01:15:31,140
a lot of logic is being done
over there in their code, right

1100
01:15:31,140 --> 01:15:31,470
here.

1101
01:15:31,530 --> 01:15:33,720
Brett Aldrich: Okay. Yeah,
that's exactly right. I'm

1102
01:15:34,770 --> 01:15:39,450
currently, so we did we, we
finished up some of the work on

1103
01:15:39,450 --> 01:15:43,350
our nav two Zed client today. So
this is the the client and smack

1104
01:15:43,350 --> 01:15:47,940
two that we use to interact with
navigation. And it's coming in

1105
01:15:47,970 --> 01:15:52,950
at about 7500 lines of code. And
this is all written by this.

1106
01:15:52,980 --> 01:15:56,760
This is written by Pablo, but
Pablo is an expert in

1107
01:15:56,760 --> 01:16:03,810
navigation, you know. And so I'm
imagining a world where if SMAC

1108
01:16:03,810 --> 01:16:07,140
becomes a standard, right, and
these clients become a standard,

1109
01:16:07,350 --> 01:16:11,250
you end up interacting, like
that balance between, let's say,

1110
01:16:11,250 --> 01:16:15,060
1000 lines of code in the
application in 110,000, in

1111
01:16:15,090 --> 01:16:19,530
something like NAB two
rebalances to something like 10

1112
01:16:19,530 --> 01:16:23,640
to 12,000 lines of code and a
client. And then my hope would

1113
01:16:23,640 --> 01:16:28,410
be that, let's say nav two could
come down to 70,000 lines of

1114
01:16:28,410 --> 01:16:30,930
code 65,000, something will you
get

1115
01:16:30,960 --> 01:16:34,290
Audrow Nash: by using less lines
of code? I'm sure storage and

1116
01:16:34,290 --> 01:16:38,970
compile time and things. But
what are the benefits?

1117
01:16:39,480 --> 01:16:41,760
Brett Aldrich: Well, there's
those and those add up, you

1118
01:16:41,760 --> 01:16:43,260
know, if you figure it out time,

1119
01:16:43,290 --> 01:16:45,240
Audrow Nash: yeah, yeah, right.
Test time.

1120
01:16:45,570 --> 01:16:49,950
Brett Aldrich: Yeah. I do agree
that, you know, measuring this

1121
01:16:49,950 --> 01:16:56,460
in lines of code is a crude, you
know, it's a crude metric. But I

1122
01:16:56,460 --> 01:17:02,700
think what you what you can get
is, I think it would be easier

1123
01:17:02,730 --> 01:17:07,410
for the developer teams at
places like naff to and move it

1124
01:17:07,410 --> 01:17:11,610
to, if they knew that the users
were going to interact with

1125
01:17:11,610 --> 01:17:15,240
their system in like a defined
way defined by like these

1126
01:17:15,240 --> 01:17:19,890
clients. Right? If if half of
the Ross community interacted

1127
01:17:19,890 --> 01:17:23,580
with move it to through a smack
client, right, it would sort of

1128
01:17:23,580 --> 01:17:28,260
like narrow the interfaces.
Yeah. Yeah. And you basically

1129
01:17:28,260 --> 01:17:33,900
get more like focus, less code
easier to maintain. And then

1130
01:17:33,900 --> 01:17:38,160
also the simplicity, you'd have
more more planners, simpler

1131
01:17:38,160 --> 01:17:42,120
planners? That would be easier
in

1132
01:17:42,120 --> 01:17:45,540
Audrow Nash: that sense. Yeah.
And one, one advantage to that,

1133
01:17:45,540 --> 01:17:49,950
that I see is, say you want
something to be like space

1134
01:17:49,980 --> 01:17:55,350
certified, or some high level of
security or you basically, the

1135
01:17:55,350 --> 01:18:00,720
code is really hard. And for
safety critical situations, you

1136
01:18:00,720 --> 01:18:05,520
can certify only a small chunk
of a larger library, rather than

1137
01:18:05,550 --> 01:18:09,720
the rest of the library. So
like, I'm sure certifying 10,000

1138
01:18:09,720 --> 01:18:13,230
lines is a lot easier than
100,000 lines. Yeah. Yeah,

1139
01:18:13,230 --> 01:18:16,620
that's right. This kind of
thing. Yeah. Let's see. And so

1140
01:18:16,620 --> 01:18:19,530
one of the things we were saying
before we started this interview

1141
01:18:19,560 --> 01:18:25,230
was you see the application of
SMAC really being for industry

1142
01:18:25,560 --> 01:18:31,320
users? And, as opposed to, like,
hobbyists, or this kind of

1143
01:18:31,320 --> 01:18:33,690
thing. Can you speak on this a
little bit? Maybe I've gotten

1144
01:18:33,690 --> 01:18:34,680
that wrong, but

1145
01:18:34,770 --> 01:18:37,920
Brett Aldrich: no, I think Well,
I think it's true. It's, I mean,

1146
01:18:37,920 --> 01:18:40,710
I hope it's Mac is used by
beginning developers, and I

1147
01:18:40,710 --> 01:18:44,100
think it has a lot to offer, you
know, beginning developers, but

1148
01:18:45,240 --> 01:18:47,940
but I don't want to, like shy
away from the question that when

1149
01:18:47,940 --> 01:18:50,580
it comes to design decisions,
you know, that are going to be

1150
01:18:50,580 --> 01:18:53,550
made. And let's say the design
decision comes down to a choice

1151
01:18:53,550 --> 01:18:56,520
between making them more
friendly for, you know, new

1152
01:18:56,520 --> 01:19:00,900
developers, or, you know, being
able to meet one day a safety

1153
01:19:00,900 --> 01:19:05,010
certification or something like
this. I always side with the

1154
01:19:05,010 --> 01:19:09,510
more high end side, it's more
important to me, that smack runs

1155
01:19:09,510 --> 01:19:12,990
on the most important robotic
systems of our era than it is,

1156
01:19:13,080 --> 01:19:19,050
you know, I'm not counting every
developer that uses it. Where,

1157
01:19:19,050 --> 01:19:22,710
though, that goes, you know, it
back to the bifurcation, though,

1158
01:19:22,710 --> 01:19:25,830
that I'm seeing in Ross, you
know, especially as I look down

1159
01:19:25,830 --> 01:19:31,380
the road, is, seems to me that
we've, we have on one hand, like

1160
01:19:31,380 --> 01:19:38,460
a research community, and this
is like students, graduate

1161
01:19:38,640 --> 01:19:43,110
students, people who are more
focused on usability and getting

1162
01:19:43,110 --> 01:19:46,380
up very quickly. I think they
tend to be more focused on their

1163
01:19:46,380 --> 01:19:50,040
algorithms. And so this would be
somebody who's using like a

1164
01:19:50,040 --> 01:19:52,740
Python node or something, they
want to get their system up and

1165
01:19:52,740 --> 01:19:56,460
running quickly. On the other
side, you've got those like

1166
01:19:56,460 --> 01:20:01,920
smack that are that are trying
They're more focused on actually

1167
01:20:01,920 --> 01:20:05,130
running in production. I think
also the work with self driving

1168
01:20:05,130 --> 01:20:09,000
cars has really led the way
here. And I love to like for

1169
01:20:09,000 --> 01:20:11,910
inspiration and where I want to
go next with smack, I look at

1170
01:20:11,910 --> 01:20:15,180
auto where I look at the work
coming out of APEX a I mean,

1171
01:20:15,180 --> 01:20:16,830
it's beautiful.

1172
01:20:17,400 --> 01:20:18,390
Audrow Nash: Yeah, absolutely.

1173
01:20:20,160 --> 01:20:22,440
Brett Aldrich: But it has some
interesting features to it. Um,

1174
01:20:22,830 --> 01:20:26,580
so, and we've done this with our
own library, we've, you know, we

1175
01:20:26,580 --> 01:20:31,860
brought in a more complex
continuous integration system.

1176
01:20:32,190 --> 01:20:35,610
And, you know, with that, I
think we have something like

1177
01:20:35,610 --> 01:20:39,600
seven, seven checks that we go
through on every pull request.

1178
01:20:41,730 --> 01:20:45,060
Every check, we add makes, it's
just one more step that a new

1179
01:20:45,060 --> 01:20:47,760
developer would have to go
through to submit a pull

1180
01:20:47,760 --> 01:20:48,330
request.

1181
01:20:50,910 --> 01:20:53,790
Audrow Nash: These might be
like, run the tests might be

1182
01:20:53,790 --> 01:20:56,940
like, do a linter, check to make
sure the code is formatted.

1183
01:20:56,940 --> 01:20:58,530
Right. So you're saying,

1184
01:20:59,250 --> 01:21:02,520
Brett Aldrich: you know, yeah,
exactly. Like, you know, and

1185
01:21:02,520 --> 01:21:07,560
hopefully, automation can help
lower that burden. But But I

1186
01:21:07,560 --> 01:21:10,410
think, too, is the libraries
like this get, you know, grow

1187
01:21:10,410 --> 01:21:15,480
more complex. It's tough
environment for beginners, you

1188
01:21:15,480 --> 01:21:21,660
know, favor, the more seasoned,
focused, I don't wanna say

1189
01:21:21,660 --> 01:21:24,450
professional, but I want to say
focused, you know, where you're

1190
01:21:24,450 --> 01:21:28,230
focused on a certain problem set
and not kind of coming in

1191
01:21:28,230 --> 01:21:34,050
quickly wanting to get something
fast. I recently, as a, as a

1192
01:21:34,050 --> 01:21:36,630
library, I won't mention it
specifically. But there's a

1193
01:21:36,630 --> 01:21:40,950
library out there that I admire
very, very much. And in

1194
01:21:40,950 --> 01:21:45,210
researching it, I, I was going
through the documentation, and I

1195
01:21:45,210 --> 01:21:51,090
found a couple of like, very
minor errors, the guys English

1196
01:21:51,090 --> 01:21:53,040
is probably their second
language, and so that, you know,

1197
01:21:53,040 --> 01:21:56,340
a few minor grammatical changes.
So I opened a pull request to

1198
01:21:56,340 --> 01:22:03,840
change it. And there's a 20 step
process. You know, this, this

1199
01:22:03,840 --> 01:22:07,020
board request, and I quit after
like, step six, I had other

1200
01:22:07,020 --> 01:22:10,290
things to do, and I pulled out
of it, I'll continue it. But I

1201
01:22:10,290 --> 01:22:14,490
think it just sort of highlights
something that we're going to

1202
01:22:14,490 --> 01:22:18,240
have to deal with as a
community. And I, again, I see

1203
01:22:18,240 --> 01:22:21,690
this sort of bifurcation between
these two different camps.

1204
01:22:22,230 --> 01:22:27,000
Audrow Nash: So one thing that I
find interesting is, like in the

1205
01:22:27,000 --> 01:22:31,830
web developing community, you
have really high quality,

1206
01:22:31,920 --> 01:22:37,110
difficult, give you everything
to play with libraries, like I

1207
01:22:37,110 --> 01:22:42,330
think it's d3, JS, d3, it's
amazing library. It's data

1208
01:22:42,330 --> 01:22:45,480
driven. It's really nice,
beautiful, beautiful, beautiful.

1209
01:22:45,750 --> 01:22:50,010
Yeah, amazing. But so that one
is incredibly difficult to get

1210
01:22:50,010 --> 01:22:51,900
into as a beginner, like I
played around with it a little

1211
01:22:51,900 --> 01:22:54,150
bit. It's very, it's awesome.
You can do great things, but

1212
01:22:54,150 --> 01:22:56,580
they're very time consuming to
do, but you can control

1213
01:22:56,610 --> 01:23:00,660
everything. Whereas then there
are I don't know, maybe like

1214
01:23:00,660 --> 01:23:05,310
chart j s or something that use
d3. But they make it a bit

1215
01:23:05,340 --> 01:23:09,180
easier for users that are more
casual or just want to get

1216
01:23:09,180 --> 01:23:14,940
something working quicker to
play around with it, or to do

1217
01:23:14,940 --> 01:23:17,670
something, but they don't have
access to all the knobs and all

1218
01:23:17,670 --> 01:23:25,110
the customization without going
into d3. JS. Yeah. Do you

1219
01:23:25,110 --> 01:23:30,210
imagine? Similar? Yeah. Okay.
Well, I wanted to make sure I'm

1220
01:23:30,240 --> 01:23:33,540
saying the right name of
something. But yeah, so I mean,

1221
01:23:33,540 --> 01:23:40,470
it's wonderful. But just it's
lower in difficulty than d3. Do

1222
01:23:40,470 --> 01:23:44,370
you imagine SMAC? Following some
sort of model similar to this to

1223
01:23:44,370 --> 01:23:45,810
make it more beginner friendly?

1224
01:23:45,870 --> 01:23:49,890
Brett Aldrich: Yeah. You know,
my So yeah, this is the

1225
01:23:49,890 --> 01:23:56,400
dynamics, I see it play there.
Um, I think that the, that what

1226
01:23:56,400 --> 01:24:02,520
smack, the advantage that smack
has is that smack as your

1227
01:24:02,520 --> 01:24:07,860
application grows, smack can
handle it. And so what that

1228
01:24:07,860 --> 01:24:14,160
allows for is the creation of
these client libraries that are

1229
01:24:14,160 --> 01:24:17,970
developed by experts, but
basically encapsulate much of

1230
01:24:17,970 --> 01:24:20,490
the higher level function, and
no, you couldn't, or you would

1231
01:24:20,490 --> 01:24:23,610
be foolish. So let's just say
we're taking navigation as an

1232
01:24:23,610 --> 01:24:29,070
example, right? I think it would
be foolish to write a client,

1233
01:24:29,550 --> 01:24:33,840
like nav to Zed for a state
machine library that couldn't

1234
01:24:33,840 --> 01:24:38,040
handle if it got to a certain
level of complexity, and then

1235
01:24:38,040 --> 01:24:40,410
that state machine library
couldn't handle it anymore.

1236
01:24:40,560 --> 01:24:44,370
You'd be foolish to write a
client for it. But because SMAC

1237
01:24:44,370 --> 01:24:47,430
can handle almost anything that
you would throw at it in terms

1238
01:24:47,430 --> 01:24:51,450
of state machine complexity. It
opens the door now for

1239
01:24:51,480 --> 01:24:54,780
specialist developers to write
client libraries. That's my

1240
01:24:54,780 --> 01:25:00,300
number one goal as we move into,
into 2022 is to expand the Every

1241
01:25:00,300 --> 01:25:04,770
horizontally with new clients
and new client developers. And

1242
01:25:04,770 --> 01:25:08,460
in that sense, I think that's
one way that we can kind of

1243
01:25:08,460 --> 01:25:11,250
escape this trap. You know what
I mean? This, this, this, this

1244
01:25:11,250 --> 01:25:14,730
d3, you know, where it's like
always, you know, if you go for

1245
01:25:14,730 --> 01:25:19,200
high icon, if you get with
capability, you can't use it,

1246
01:25:19,230 --> 01:25:24,300
you know, that, like avoiding
that, that? Yeah. And then the

1247
01:25:24,300 --> 01:25:27,720
second part of that is
cogeneration. I think, I think

1248
01:25:27,720 --> 01:25:32,010
when when we start getting
cogeneration capabilities that

1249
01:25:32,010 --> 01:25:38,400
are graphical, it, you know,
yeah, to bypass all that,

1250
01:25:38,970 --> 01:25:43,890
Audrow Nash: you can just like
visual block program, a complex

1251
01:25:43,920 --> 01:25:47,520
robotics application, that
actually does something, which

1252
01:25:47,520 --> 01:25:50,010
is not, yep, that will be super
cool.

1253
01:25:50,100 --> 01:25:51,870
Brett Aldrich: Yeah. And in
there, you know, then the

1254
01:25:51,870 --> 01:25:55,590
complexity, it wouldn't hurt you
there, either. Or you'd bypass

1255
01:25:55,590 --> 01:25:57,720
it, you'd be able to kind of
abstracted away

1256
01:25:58,620 --> 01:26:01,920
Audrow Nash: in the blocks you
use. Yeah, yeah. Um,

1257
01:26:03,180 --> 01:26:05,850
Brett Aldrich: and, and then
also has another, like, it

1258
01:26:05,850 --> 01:26:08,760
brings in another type of
efficiency where it's important.

1259
01:26:08,880 --> 01:26:14,010
So the SM reference library, you
know, the minute a developer

1260
01:26:14,010 --> 01:26:16,260
comes, they can they can get
started with a state machine

1261
01:26:16,260 --> 01:26:19,830
there that's guaranteed to
compile and run. Simulation is

1262
01:26:19,830 --> 01:26:24,090
set up. But I think the other
way to capture greater

1263
01:26:24,090 --> 01:26:27,870
efficiency is on the back end
where you don't, you don't have

1264
01:26:27,870 --> 01:26:31,260
to upgrade. You know, for
instance, back to that, that

1265
01:26:31,260 --> 01:26:34,530
DARPA team we were discussing
earlier, that started off with

1266
01:26:34,530 --> 01:26:38,700
four states, their state machine
eventually grew to 15. Now,

1267
01:26:39,480 --> 01:26:43,320
let's just say that it kept
going, you know, and now they're

1268
01:26:43,320 --> 01:26:47,700
45. And it's not working
anymore. You know, like, the

1269
01:26:47,700 --> 01:26:51,600
things that they were dealing
with? Probably they don't, who

1270
01:26:51,600 --> 01:26:56,640
knows how they're visualizing
it, you know? Yeah. But if

1271
01:26:56,700 --> 01:26:59,610
you're in a library, like smack
that, you know, can handle that

1272
01:26:59,610 --> 01:27:02,910
growth, well, then you never
have to refactor or transfer

1273
01:27:02,910 --> 01:27:06,030
your code base. And that's a
big, you know, that's another

1274
01:27:06,030 --> 01:27:10,230
like form of deficiency that I'm
hoping that, that we can verify.

1275
01:27:10,830 --> 01:27:14,340
Audrow Nash: Yeah, you had that
foresight. And you can see, oh,

1276
01:27:14,370 --> 01:27:17,250
eventually we're going to need
it. Yeah. See, there's there's

1277
01:27:17,250 --> 01:27:20,460
several things in that I've seen
that are similar, where they're

1278
01:27:20,460 --> 01:27:22,650
like, you're going to need to
use this. So might as well use

1279
01:27:22,650 --> 01:27:25,800
it anyway. Kind of thing. Like
might as well use it to start.

1280
01:27:26,130 --> 01:27:26,730
Yeah.

1281
01:27:27,600 --> 01:27:29,700
Brett Aldrich: Gotcha. And into
your architecture. Yep.

1282
01:27:30,780 --> 01:27:34,290
Audrow Nash: Now, I know. So we
are running out of time, we were

1283
01:27:34,290 --> 01:27:37,020
booked for two hours. We're
coming up on the end. Are you

1284
01:27:37,020 --> 01:27:38,760
okay to go a little bit longer?
Yeah, let's

1285
01:27:38,760 --> 01:27:40,200
Unknown: do it. Okay.

1286
01:27:41,160 --> 01:27:47,550
Audrow Nash: So one thing that I
want to so SMAC is basically for

1287
01:27:47,670 --> 01:27:52,350
control, high level control of
robotics applications. How does

1288
01:27:52,350 --> 01:27:56,970
it compare to other control
patterns, such as, like,

1289
01:27:57,210 --> 01:28:02,130
behavior trees, and I don't
know, whatever other whenever I

1290
01:28:02,160 --> 01:28:03,540
what other things exist?

1291
01:28:04,500 --> 01:28:07,680
Brett Aldrich: I think I think
with behavior trees, you know,

1292
01:28:07,710 --> 01:28:10,230
well, okay. Well, I guess the
key question there is, what do

1293
01:28:10,230 --> 01:28:15,510
you mean by exist? If we're
talking about, or patterns

1294
01:28:15,510 --> 01:28:20,280
Audrow Nash: that developers use
now for control of robots that

1295
01:28:20,310 --> 01:28:25,440
are doing reasonably complex
applications, you know, control

1296
01:28:25,440 --> 01:28:26,970
in existing applications?

1297
01:28:27,210 --> 01:28:28,920
Brett Aldrich: Yeah, you know,
I'll be honest, in that there

1298
01:28:28,920 --> 01:28:31,830
really isn't much available.
It's hard to comment on it. You

1299
01:28:31,830 --> 01:28:34,620
know, because there's, there's,
and I think this is one of the

1300
01:28:34,620 --> 01:28:40,590
real it's a problem for us as a
community at the moment, is that

1301
01:28:40,920 --> 01:28:44,190
it within the answer is we need
more demos with links to the

1302
01:28:44,190 --> 01:28:49,170
source code, you know, because I
think a lot of it sort of

1303
01:28:49,170 --> 01:28:53,550
reminds me in the days, you
know, for those listening off

1304
01:28:53,550 --> 01:28:56,310
camera Audrow And I before that
we're talking a little bit

1305
01:28:56,310 --> 01:29:00,330
about, we both have an interest
in jujitsu. And it reminds me in

1306
01:29:00,330 --> 01:29:05,610
the moment of like, the days
before the first UFC where, you

1307
01:29:05,610 --> 01:29:11,250
know, what would happen when
when a kickboxer fought a sumo

1308
01:29:11,250 --> 01:29:17,400
wrestler like no one really
knew, you know? And? Yeah, I

1309
01:29:17,400 --> 01:29:20,430
feel like the demos with the
sort with links to the source

1310
01:29:20,430 --> 01:29:24,300
code are a crucial part of
showing like, Okay, well, you

1311
01:29:24,300 --> 01:29:30,360
know, if it can do it, let's
prove it. And from what I've

1312
01:29:30,360 --> 01:29:35,130
seen, is, you know, of what's
out there. It seems like most

1313
01:29:35,130 --> 01:29:40,470
people are rolling with like a
roll your own solution. You

1314
01:29:40,470 --> 01:29:43,350
know, they're starting off with
like, I don't know, maybe a

1315
01:29:43,350 --> 01:29:46,560
state pattern or something like
a gang of four kind of pattern.

1316
01:29:46,860 --> 01:29:52,470
And it's good, although, I think
it leads us to the sort of thing

1317
01:29:52,470 --> 01:29:54,810
where they develop something
that's pretty cool. Let's say

1318
01:29:54,810 --> 01:29:59,790
it's 1520 states, and then it's
but they can't maintain it. And

1319
01:29:59,790 --> 01:30:02,400
so A lot of that work is lost,
you know?

1320
01:30:03,840 --> 01:30:06,960
Audrow Nash: Yeah, nothing,
nothing generalizes. Like it's

1321
01:30:06,960 --> 01:30:09,510
hard to pull components from it,
it's hard to grow the

1322
01:30:09,510 --> 01:30:15,810
application any larger. And it's
also intertwined with the state

1323
01:30:15,810 --> 01:30:19,350
representation that they have
already, that it's very hard to

1324
01:30:19,350 --> 01:30:22,950
pull out the parts into a
different way of organizing

1325
01:30:22,950 --> 01:30:23,850
them, perhaps.

1326
01:30:24,150 --> 01:30:28,650
Brett Aldrich: Yeah, yeah. And,
and I think that hurts us all

1327
01:30:28,650 --> 01:30:33,810
over the place, you know, where?
I mean, they, you know, for

1328
01:30:33,840 --> 01:30:37,260
instance, and I know, we're
trying to harvest what's coming

1329
01:30:37,260 --> 01:30:42,900
out of the DARPA subterranean
challenge. But I think we'll be

1330
01:30:42,900 --> 01:30:47,670
lucky if we get a couple of
planners. We'll get lucky if we,

1331
01:30:48,990 --> 01:30:52,170
if we get a few algorithms, but
I think the prospects of us

1332
01:30:52,170 --> 01:30:55,440
finding like some type of state
machine architecture that we can

1333
01:30:55,440 --> 01:31:00,540
pull out, I mean, very low, very
low, it would require, it would

1334
01:31:00,540 --> 01:31:04,530
require an advanced team. I'm
going to adjust my lighting here

1335
01:31:04,530 --> 01:31:12,030
a little bit. Yan is going down
one moment. Has this a better?

1336
01:31:12,690 --> 01:31:14,670
Very bright? Yeah, yeah. Okay,
cool.

1337
01:31:18,660 --> 01:31:23,310
Audrow Nash: So, yeah. And then,
so we just, um, can you speak a

1338
01:31:23,310 --> 01:31:28,260
little bit about the differences
between state machines and a

1339
01:31:28,680 --> 01:31:32,490
state or a behavior tree based
approach? Just kind of at a high

1340
01:31:32,490 --> 01:31:33,180
level? Because

1341
01:31:33,480 --> 01:31:38,820
Brett Aldrich: high level? Yeah,
the, I think the the most

1342
01:31:39,090 --> 01:31:43,230
fundamental differences between
this one way and two way path of

1343
01:31:43,230 --> 01:31:48,510
control. So in that sense, state
machines are, I guess, more like

1344
01:31:48,510 --> 01:31:52,350
a go to statement, although I, I
have problems with that analogy.

1345
01:31:53,250 --> 01:31:56,640
Whereas behavior trees are more
like a while loop. You know,

1346
01:31:56,640 --> 01:32:02,220
when, when you look at a
behavior tree, and it's the

1347
01:32:02,220 --> 01:32:08,100
ticking. That is like the key
part that makes it a while loop,

1348
01:32:08,130 --> 01:32:09,900
right, that you tick through all
the

1349
01:32:10,350 --> 01:32:13,500
Audrow Nash: skills, you keep
polling the current state or

1350
01:32:13,530 --> 01:32:18,000
something, too. So just just to
just give a little background to

1351
01:32:18,000 --> 01:32:21,930
those who don't know, for the
behavior tree, just an example

1352
01:32:21,930 --> 01:32:27,180
of what it might look like, is
in a video game, I think I read

1353
01:32:27,180 --> 01:32:32,700
on your blog, this MAC one, that
Halo two was the first video

1354
01:32:32,700 --> 01:32:39,000
game yeah, control before? Yep,
yep. So what they would do an

1355
01:32:39,000 --> 01:32:42,900
example of how a character might
be controlled in a state

1356
01:32:42,900 --> 01:32:46,650
machine. So in Halo two, for
example, if you had like, one of

1357
01:32:46,650 --> 01:32:51,210
those little grunt, aliens, it
might, if it doesn't see you, it

1358
01:32:51,210 --> 01:32:56,370
might just be kind of idle. Or
actually, I, let's see, actually

1359
01:32:56,370 --> 01:32:58,500
another example. Because I'm
going to get confused with that

1360
01:32:58,500 --> 01:33:01,290
one, I'm kind of going into a
state machine direction. If I

1361
01:33:01,290 --> 01:33:05,370
have a character and it wants to
get into a house, for a behavior

1362
01:33:05,370 --> 01:33:10,500
tree, that behavior tree might
go and look to see if the doors

1363
01:33:10,500 --> 01:33:15,510
open. And if the door is not
open, then it might go see if it

1364
01:33:15,510 --> 01:33:19,590
has keys. And if it has keys,
then it might use them. And if

1365
01:33:19,590 --> 01:33:25,470
not, it will go and see if
someone like try to knock and it

1366
01:33:25,470 --> 01:33:29,460
progressively goes through these
things. Eventually, it might be

1367
01:33:29,460 --> 01:33:33,360
like, is there a window that can
be broken to get inside? or

1368
01:33:33,360 --> 01:33:37,650
something? But it's a series of
like steps that are all like

1369
01:33:37,680 --> 01:33:41,010
conditioned on each other? Do
you agree with that or anything?

1370
01:33:41,850 --> 01:33:45,990
Brett Aldrich: I agree. Okay,
that conditional approach to end

1371
01:33:45,990 --> 01:33:46,560
the polling,

1372
01:33:47,460 --> 01:33:51,540
Audrow Nash: the polling part is
that at each time you go, what

1373
01:33:51,540 --> 01:33:55,320
have I tried before? And it kind
of brings you down each of the

1374
01:33:55,320 --> 01:33:59,190
leaves for this? And that would
be like, Have I tried keys? Have

1375
01:33:59,190 --> 01:34:02,610
I tried this? Have I tried that?
Okay, I'm here with try next,

1376
01:34:02,910 --> 01:34:03,780
this kind of thing.

1377
01:34:04,350 --> 01:34:09,720
Brett Aldrich: There's that.
And, and then there's no events?

1378
01:34:10,560 --> 01:34:13,980
And I think that's now that this
is true for behavior trees dot

1379
01:34:13,980 --> 01:34:17,850
cpp. And in a number of other
behavior tree libraries, I

1380
01:34:17,850 --> 01:34:18,270
think.

1381
01:34:19,380 --> 01:34:22,050
Audrow Nash: So there's no
events, that means it's hard to

1382
01:34:22,050 --> 01:34:25,620
have an event trigger something
in the behavior. That's right.

1383
01:34:25,620 --> 01:34:29,280
So it's kind of weird, because
it's based on like an existence

1384
01:34:29,280 --> 01:34:34,530
of the state. Oh, I see why that
gets confusing. Because if

1385
01:34:34,530 --> 01:34:36,630
you're running through your
statements, but then all of a

1386
01:34:36,630 --> 01:34:40,230
sudden the state changes now you
have to like recall everything.

1387
01:34:40,860 --> 01:34:41,460
That's right.

1388
01:34:41,520 --> 01:34:44,820
Brett Aldrich: That's right. And
that's if you have, that's when

1389
01:34:44,820 --> 01:34:49,950
you start to have So in a normal
behavior, how do I say this?

1390
01:34:51,360 --> 01:34:58,530
Google so so behavior trees
originally came out in 2004. And

1391
01:34:59,070 --> 01:35:05,850
they you got started in, in, you
know, games modeling, they call

1392
01:35:05,850 --> 01:35:09,930
them NPCs, non player
characters, which I have a

1393
01:35:09,930 --> 01:35:12,630
number of problems with in a
robotic context. I mean, these,

1394
01:35:12,660 --> 01:35:15,840
these creatures don't have any
kind of control system, they

1395
01:35:15,840 --> 01:35:17,760
don't have any kind of
orthogonality, there's no

1396
01:35:17,760 --> 01:35:28,050
liability. Then those, I'm gonna
call that the first generation

1397
01:35:28,080 --> 01:35:31,440
implementations, they did get
some success in the gaming

1398
01:35:31,440 --> 01:35:34,230
world. And so and I think for
that reason, people thought,

1399
01:35:34,260 --> 01:35:36,840
Okay, well, we can use them from
robotics, because Robotics has

1400
01:35:36,840 --> 01:35:40,920
always been, we've always stolen
from every other field out

1401
01:35:40,920 --> 01:35:48,420
there, right. But later, well,
as of today, right, there are no

1402
01:35:48,420 --> 01:35:52,890
behavior, I'm 99% sure that
there are no pure behavior tree

1403
01:35:52,890 --> 01:35:55,860
implementations left in the
gaming world, and those that

1404
01:35:55,860 --> 01:35:59,160
remain have all moved over to
event driven behavior tree

1405
01:35:59,160 --> 01:36:03,780
mouse. And event driven behavior
tree, what you need is you need

1406
01:36:03,780 --> 01:36:08,730
a, you need another thread, you
need like an observer thread,

1407
01:36:09,000 --> 01:36:11,670
you know, to check your events
coming in, amongst other

1408
01:36:11,670 --> 01:36:12,120
changes.

1409
01:36:13,230 --> 01:36:16,200
Audrow Nash: So that's it just
just from like, a high level to

1410
01:36:16,200 --> 01:36:19,140
see if I understand what it is
that you have the two threads,

1411
01:36:19,140 --> 01:36:23,430
you have the one checking for
events, what kind of so an event

1412
01:36:23,700 --> 01:36:28,860
occurs, something has changed.
Now your state diagram or your

1413
01:36:28,920 --> 01:36:32,280
behavior tree, would it just
like change all of a sudden?

1414
01:36:32,850 --> 01:36:35,640
Brett Aldrich: Good question.
This this, this would depend on

1415
01:36:35,640 --> 01:36:39,870
the implementation. I know of
two different methods. One of

1416
01:36:39,870 --> 01:36:44,610
them is like, yeah, you just
repol everything in the tree

1417
01:36:44,790 --> 01:36:49,170
every time an event occurs. And
that's like, that keeps it more

1418
01:36:49,170 --> 01:36:54,150
similar to the original behavior
tree design, I guess. And then

1419
01:36:54,150 --> 01:36:58,410
there's a second model where
you're keeping track of all it's

1420
01:36:58,410 --> 01:37:01,380
a more advanced method where
you're keeping track of

1421
01:37:01,380 --> 01:37:05,760
everything that's happening at
that point. I question. I mean,

1422
01:37:05,790 --> 01:37:08,550
I think you've actually got a
state machine only, you're

1423
01:37:08,550 --> 01:37:15,480
keeping track of state in a set
kind of way. Yeah. The thing

1424
01:37:15,480 --> 01:37:20,910
about event driven behavior tree
libraries, is that I think

1425
01:37:20,910 --> 01:37:24,960
they're highly experimental. I
mean, there's only four that I'm

1426
01:37:24,960 --> 01:37:30,000
aware of, you got Unreal Engine,
you've got one for unity called

1427
01:37:30,000 --> 01:37:33,600
MP behave. And that's like a,
like a third party plugin or

1428
01:37:33,600 --> 01:37:37,830
something. I don't like,
whatever. Okay. Yeah, it's like,

1429
01:37:37,860 --> 01:37:41,040
it's like a, like a plug in type
deal, then you've got the Cry

1430
01:37:41,040 --> 01:37:47,250
Engine, which I don't know that
much about. And one other one,

1431
01:37:47,250 --> 01:37:50,010
that doesn't count either, it's
not important, the only one of

1432
01:37:50,010 --> 01:37:54,450
those that matter in any sort of
way, to me is unreal engine

1433
01:37:54,450 --> 01:38:01,470
four. And the big difference
there is that they these, they

1434
01:38:01,470 --> 01:38:06,630
cannot handle concurrency. You
cannot. If we look at let's say

1435
01:38:06,630 --> 01:38:08,970
the implementation of Unreal
Engine four, right, the only

1436
01:38:08,970 --> 01:38:12,660
event driven behavior tree
library that I can think of,

1437
01:38:14,130 --> 01:38:18,180
they don't support multiple
orthogonal. And in fact, if

1438
01:38:18,180 --> 01:38:22,410
somebody cares to look into it,
in the documentation, you can

1439
01:38:22,410 --> 01:38:25,350
look up the simple parallel
node, where, you know, this

1440
01:38:25,350 --> 01:38:27,630
would have been the node where
they would have handled in their

1441
01:38:27,630 --> 01:38:30,450
parallel nodes, you know, you
could have multiple orthogonal,

1442
01:38:30,660 --> 01:38:34,170
they punted, you're only allowed
to have one a synchronous one,

1443
01:38:34,230 --> 01:38:38,040
and one synchronous, and that's
it. So you would never be able

1444
01:38:38,040 --> 01:38:42,330
to run like the kind of
orthogonality that that would be

1445
01:38:42,330 --> 01:38:48,060
required on that field work
robotics robot that we saw, or

1446
01:38:48,360 --> 01:38:54,090
let's say, let's say some type
of like military submarine, you

1447
01:38:54,090 --> 01:38:57,210
know, where, who knows what
they're gonna or like, hell,

1448
01:38:57,240 --> 01:39:00,960
like an Apache helicopter, where
there's something like 48 sensor

1449
01:39:00,960 --> 01:39:04,290
systems. Yeah, and complex
sensor systems, right? Not just

1450
01:39:05,280 --> 01:39:08,220
not just like a proximity
sensor, right? But instead, it's

1451
01:39:08,220 --> 01:39:14,040
like a 3d scanning array, and IR
scattering the rig. And so to

1452
01:39:14,040 --> 01:39:18,330
me, that's the that's the main
difficulty. Now there, there

1453
01:39:18,330 --> 01:39:22,860
will be a lot of debate. I've
been involved with debates with

1454
01:39:22,920 --> 01:39:28,290
the proponents of behavior
trees. But that's that's, that,

1455
01:39:28,320 --> 01:39:32,610
to me, is the most immediate,
short term shortcoming they have

1456
01:39:32,760 --> 01:39:39,300
I also suspect that that there
will be a way to prove

1457
01:39:39,300 --> 01:39:43,950
mathematically that one state
machines are more well, I know

1458
01:39:43,950 --> 01:39:45,570
that you could prove
mathematically that state

1459
01:39:45,570 --> 01:39:48,840
machines are more expressive
simply because the N times end

1460
01:39:48,840 --> 01:39:58,020
problem is a is a. The flip side
of that is that you have finer

1461
01:39:58,020 --> 01:40:00,600
grained control, you know for
instance, let's See, I've got a

1462
01:40:00,600 --> 01:40:04,080
200 state state machine. And at
state one nine, you

1463
01:40:04,080 --> 01:40:06,540
Audrow Nash: can explicitly go
from each of the states to every

1464
01:40:06,540 --> 01:40:07,470
other state. Yeah.

1465
01:40:08,010 --> 01:40:11,160
Brett Aldrich: Handling, like
certain corner cases. So in that

1466
01:40:11,160 --> 01:40:13,110
sense, I think the the ideal
that you get more

1467
01:40:13,140 --> 01:40:16,170
Audrow Nash: probably way better
for testing. I imagine it's much

1468
01:40:16,170 --> 01:40:19,320
easier to test all the state
transitions explicitly, with

1469
01:40:19,320 --> 01:40:20,700
this kind of representation.

1470
01:40:22,080 --> 01:40:24,690
Brett Aldrich: I would think so.
Yeah, the fact that you can do a

1471
01:40:24,690 --> 01:40:26,550
lot of it at compile time, I
think that's true.

1472
01:40:26,730 --> 01:40:29,700
Audrow Nash: Anyone, like, if I
want to simulate the robot for

1473
01:40:29,700 --> 01:40:32,700
like, additional testing, so
like, I know, you can do a lot

1474
01:40:32,700 --> 01:40:35,670
of the compile time testing,
which makes sure everything has

1475
01:40:35,670 --> 01:40:39,150
a connection to everything, or
to so all the connections are

1476
01:40:39,150 --> 01:40:44,100
set up. But having like, if I
wanted to run in simulation, I

1477
01:40:44,100 --> 01:40:48,870
could target each of the
transitions for a candidate for

1478
01:40:48,870 --> 01:40:51,780
testing, which would be nice and
explicit.

1479
01:40:52,260 --> 01:40:56,700
Brett Aldrich: Yep. And then to
with this gets off into, like,

1480
01:40:56,700 --> 01:41:00,750
where I see the future gone, but
fellow, in studying the history

1481
01:41:00,750 --> 01:41:03,390
of state machines in different
domains, and I've studied them

1482
01:41:03,390 --> 01:41:08,610
in the electronics domain, the,
the, I call it computing, I've

1483
01:41:08,610 --> 01:41:10,830
been able to track down the
earliest state machine and a

1484
01:41:10,830 --> 01:41:18,210
computer to the 1965 version of
the IBM Oh s 3/61, one that I

1485
01:41:18,210 --> 01:41:20,100
was able to find in
documentation where you see a

1486
01:41:20,100 --> 01:41:25,500
very simple state machine on the
computer. But in the in the

1487
01:41:25,500 --> 01:41:31,410
networking domain. You see state
machines arising from almost the

1488
01:41:31,410 --> 01:41:35,250
beginning, the beginnings of the
field of protocol engineering.

1489
01:41:37,260 --> 01:41:41,190
And TCP IP is a giant state
machine. But one of the things

1490
01:41:41,190 --> 01:41:46,770
that happened in the late 70s
was they started creating, like

1491
01:41:46,860 --> 01:41:50,880
dual state machines setups,
where one state machine would

1492
01:41:50,880 --> 01:41:53,940
test the protocol of another
state machine, totally

1493
01:41:53,940 --> 01:41:58,590
automated. And there were cases
in the development of ARPANET

1494
01:41:58,740 --> 01:42:03,990
where this technique exposed
something like 256 bugs with

1495
01:42:04,140 --> 01:42:08,760
without any human involvement.
Crazy, got me thinking about

1496
01:42:08,760 --> 01:42:12,540
like, Okay, wait a minute, how
do we start creating? Or how do

1497
01:42:12,540 --> 01:42:16,320
we start changing our automated
testing, right to start

1498
01:42:16,320 --> 01:42:19,830
incorporating state machines on
each side testing the other

1499
01:42:19,830 --> 01:42:24,360
state machine? This is one of
those areas where I, you know, I

1500
01:42:24,360 --> 01:42:30,960
have hopes for new fields, new
fields to arise and new types of

1501
01:42:30,960 --> 01:42:34,530
efficiencies to be gained. But
back to the behavior trees, I

1502
01:42:34,530 --> 01:42:40,980
think, I think at the
application layer, I'm yet to

1503
01:42:40,980 --> 01:42:45,330
see an example of behavior
trees, where we've got a demo

1504
01:42:45,540 --> 01:42:48,510
and the source codes, side by
side in robotics.

1505
01:42:51,300 --> 01:42:52,770
Audrow Nash: Does that mean
evaluate?

1506
01:42:53,070 --> 01:42:58,440
Brett Aldrich: Oh, yeah, that
makes it hard to comment on. And

1507
01:42:58,440 --> 01:43:04,710
I, I don't know, I feel that,
that we're trying to deal with

1508
01:43:04,740 --> 01:43:08,040
that problem of complexity, in a
sense by saying, Well, you don't

1509
01:43:08,040 --> 01:43:11,580
even need state machines. And I
have a hard time, I have a hard

1510
01:43:11,580 --> 01:43:15,630
time going down. That said, I do
want to say that I believe in

1511
01:43:15,630 --> 01:43:20,250
freedom. And although I may
disagree with something, hey, I

1512
01:43:20,250 --> 01:43:24,390
want people to know the way they
want to code. And, and let the

1513
01:43:24,390 --> 01:43:29,280
best man win. Let the best man
win. Let's let's you know, going

1514
01:43:29,280 --> 01:43:35,790
back to our discussions about
jujitsu. I was listening to an

1515
01:43:35,790 --> 01:43:38,310
interview with Hickson Gracie
the other day. And he was asked

1516
01:43:38,340 --> 01:43:43,680
to compare the cultures of Japan
where jujitsu originated in

1517
01:43:43,680 --> 01:43:48,840
Brazil. And what he said was
that, you know, Gracie Jiu Jitsu

1518
01:43:48,840 --> 01:43:53,280
could only have originated in
Brazil, because the difference

1519
01:43:53,280 --> 01:43:57,600
in culture cultures were in
Brazil, there was not this sense

1520
01:43:57,600 --> 01:44:02,520
of respect that there wasn't
like, you're very, very

1521
01:44:02,520 --> 01:44:06,900
respectful. Right? Okay. In
Brazil. He said No, like people

1522
01:44:06,900 --> 01:44:09,150
would show up at my father's
studio in the middle of the

1523
01:44:09,150 --> 01:44:13,710
night and want to test us out
with a fight. Wow. Yeah, it was

1524
01:44:13,710 --> 01:44:17,340
it was like the like you had to
be ready to, to duke it out at

1525
01:44:17,340 --> 01:44:21,540
any moment. And I think we need
a little bit more of that in

1526
01:44:21,540 --> 01:44:25,380
Ross. But you know, let's, let's
put the players on the field.

1527
01:44:25,440 --> 01:44:26,130
Let's let him

1528
01:44:26,130 --> 01:44:28,260
Audrow Nash: on. And let them
evaluate.

1529
01:44:28,290 --> 01:44:30,480
Brett Aldrich: Definitely. Yeah,
I think that I think the

1530
01:44:30,480 --> 01:44:33,090
community benefits. Yes, yeah.
Cuz

1531
01:44:33,090 --> 01:44:35,910
Audrow Nash: you get to evaluate
the ideas and actually compare

1532
01:44:35,910 --> 01:44:41,490
them fairly. And then juice from
there. What do you so going

1533
01:44:41,490 --> 01:44:46,620
forward? What's the future of
snack look like? Where you guys

1534
01:44:46,620 --> 01:44:49,440
going with your implementation?
And what do you see in the next

1535
01:44:49,440 --> 01:44:50,070
few years?

1536
01:44:50,520 --> 01:44:53,280
Brett Aldrich: I see too, you
know, a few years. I don't look

1537
01:44:53,400 --> 01:44:57,540
that far down the road. I'm more
like looking down on your

1538
01:44:57,630 --> 01:45:02,940
quarters to 2022 and that I
think there's really two things

1539
01:45:02,970 --> 01:45:07,980
that that we need to do, the
first thing I need to do is I

1540
01:45:07,980 --> 01:45:10,530
need to expand it into more of a
community project. And one of

1541
01:45:10,530 --> 01:45:14,790
the things I'm looking for there
is a talented pedagogue, because

1542
01:45:15,000 --> 01:45:23,130
I'm not the guy to, to teach
newbies about smack, I'm gonna

1543
01:45:23,130 --> 01:45:26,040
try, I'm gonna do my best. But I
know that there would be

1544
01:45:26,040 --> 01:45:29,520
somebody out there who's better
than me at doing it. And that I

1545
01:45:29,520 --> 01:45:32,400
think, is probably the biggest
weak point of the library at the

1546
01:45:32,400 --> 01:45:36,690
moment, partly because of the
way we bootstrapped it. But we

1547
01:45:36,690 --> 01:45:38,910
could use a lot more
documentation, we could use a

1548
01:45:38,910 --> 01:45:44,040
lot more tutorials, and, you
know, fostering almost into more

1549
01:45:44,040 --> 01:45:47,130
of a community beyond just the
robust soft team, which is where

1550
01:45:47,130 --> 01:45:50,310
we're at currently, I would say
we've got a handful of people

1551
01:45:50,310 --> 01:45:54,540
who've committed pull requests,
but it's a handful, and, and for

1552
01:45:54,630 --> 01:45:57,180
what I want to accomplish with
the library that needs to grow

1553
01:45:57,180 --> 01:46:00,510
substantially. And then the
second thing is the horizontal

1554
01:46:01,050 --> 01:46:07,050
growth. And that's basically new
clients. So clients, four legged

1555
01:46:07,050 --> 01:46:13,410
robot clients for naval, ps4 is
another one that's like really

1556
01:46:13,410 --> 01:46:17,460
high on my list. That's drone
community, correct drones, but

1557
01:46:17,460 --> 01:46:20,190
you could also use pics for
based systems for like

1558
01:46:20,190 --> 01:46:22,020
underwater sub stuff like that.

1559
01:46:22,740 --> 01:46:23,970
Audrow Nash: So cool. Yeah.

1560
01:46:25,860 --> 01:46:28,620
Brett Aldrich: One an autoware.
Client. I really think that

1561
01:46:28,620 --> 01:46:33,450
that's like, that would be very
cool. Yeah, opens up a lot of

1562
01:46:33,450 --> 01:46:35,790
possibilities, particularly for
multistage missions, like we

1563
01:46:35,790 --> 01:46:40,590
were talking about earlier.
Other ones, let's see, there's

1564
01:46:40,590 --> 01:46:42,990
the moose system for naval.

1565
01:46:45,450 --> 01:46:51,150
Would you call it but basically,
naval robotics? And let's see

1566
01:46:51,150 --> 01:46:56,100
what else? I would say that
that's basically it, though, the

1567
01:46:56,100 --> 01:46:58,620
idea of horizontal integration.
Yep.

1568
01:47:00,990 --> 01:47:05,910
Audrow Nash: And then wrapping
up? What advice do you have for

1569
01:47:05,910 --> 01:47:08,610
someone who is just getting into
robotics?

1570
01:47:10,050 --> 01:47:17,220
Brett Aldrich: You know, I'm
very hesitant to give advice to

1571
01:47:17,220 --> 01:47:22,020
anybody. I'm not sure they want
to do things away. That's

1572
01:47:22,260 --> 01:47:27,930
exactly the smoothest route. But
I would say this, if someone

1573
01:47:27,930 --> 01:47:31,290
looked at my career that they
would find, and a lot of this

1574
01:47:31,410 --> 01:47:35,130
hasn't been public, because it
was what the real. But over and

1575
01:47:35,130 --> 01:47:40,140
over, I've gone into development
projects that I really had no

1576
01:47:40,140 --> 01:47:45,360
business, succeeding, you know,
it would like if you if you look

1577
01:47:45,360 --> 01:47:48,810
before, like, what would what
would this guy's odds of success

1578
01:47:48,810 --> 01:47:51,330
be? You think they were low, and
over and over, I've come out of

1579
01:47:51,330 --> 01:47:54,690
them on top. And I there's one
secret, and that is have a spec,

1580
01:47:55,230 --> 01:47:59,700
not even have a good one, just
have one. I originally got a

1581
01:47:59,700 --> 01:48:04,980
spell book, spec, I'm talking
about a design document, minimum

1582
01:48:04,980 --> 01:48:09,900
three pages, but it can grow,
you know, but it's where write

1583
01:48:09,900 --> 01:48:13,050
it down. Particularly if other
developers are going to get

1584
01:48:13,050 --> 01:48:18,300
involved. You know, it's, it's,
it's just, you'd be surprised.

1585
01:48:19,410 --> 01:48:23,550
I've ran into people whose
credentials were so they looked

1586
01:48:23,550 --> 01:48:29,910
so good. And, but they didn't
write a spec. And know, the code

1587
01:48:29,910 --> 01:48:35,190
wasn't that good. You know, when
you have one, you'll notice you

1588
01:48:35,190 --> 01:48:39,030
know, that? No, like, even the
again, you may not have that

1589
01:48:39,030 --> 01:48:43,470
much experience, but with armed
with a spec you can do, you

1590
01:48:43,470 --> 01:48:44,430
should believe in yourself.

1591
01:48:45,090 --> 01:48:48,000
Audrow Nash: Gotcha. So you, you
basically you think it through

1592
01:48:48,000 --> 01:48:52,590
and you develop some sort of
spec sheet. And with that you're

1593
01:48:52,590 --> 01:48:56,580
a lot more focused and able to
kind of knock down the task to

1594
01:48:56,580 --> 01:49:01,470
achieve something rather than
not being focused through and

1595
01:49:01,470 --> 01:49:05,100
trying to, I don't know, you're
not focused on the end. If

1596
01:49:05,100 --> 01:49:08,220
you're, if you don't have a
spec, maybe? Yeah,

1597
01:49:08,280 --> 01:49:12,510
Brett Aldrich: I think too, it
allowed me to, to identify

1598
01:49:13,260 --> 01:49:16,020
difficulties problems. And often
there were multiple ones, you

1599
01:49:16,020 --> 01:49:19,980
know, like, like in something
and overcome them, you know, and

1600
01:49:19,980 --> 01:49:23,610
start to like, get your, they
start to get your grips on a

1601
01:49:23,610 --> 01:49:28,230
problem, you start to come up
with solutions. Often that don't

1602
01:49:28,230 --> 01:49:33,240
work. But yeah, and I've noticed
it more and more that when I

1603
01:49:33,330 --> 01:49:35,610
like, if I'm working with
something I say, Well, do you

1604
01:49:35,610 --> 01:49:43,230
have a spec, and it's rare. It's
rare, but and that originally, I

1605
01:49:43,230 --> 01:49:46,980
originally got that idea from
the book, Joel on software. And

1606
01:49:46,980 --> 01:49:50,190
that's from Joel Spolsky, who
was one of the original

1607
01:49:50,190 --> 01:49:55,500
Microsoft program managers at a
time when Microsoft really led

1608
01:49:55,500 --> 01:49:58,260
the way in terms of how to
produce code. And so that's

1609
01:49:58,260 --> 01:50:01,770
really the that's really the The
one piece of advice I would

1610
01:50:01,770 --> 01:50:06,660
give, I don't know if it'll be
enough to accomplish, you know

1611
01:50:06,690 --> 01:50:10,620
what someone would want to, you
know? First, you gotta have a

1612
01:50:10,620 --> 01:50:13,770
goal. And I don't know if a spec
alone will get you there. But

1613
01:50:13,770 --> 01:50:14,910
without one, you're done.

1614
01:50:16,680 --> 01:50:22,800
Audrow Nash: Awesome. Okay. Now,
do you have any links or contact

1615
01:50:22,800 --> 01:50:26,130
info or anything that you would
like to share? Yeah, so

1616
01:50:26,850 --> 01:50:32,130
Brett Aldrich: roba soft.ai is
our website. And then the other

1617
01:50:32,130 --> 01:50:34,680
place that, you know, for,
especially the audience of this

1618
01:50:34,680 --> 01:50:40,410
podcast, is the smack to repo on
GitHub. And, as always the most

1619
01:50:40,440 --> 01:50:44,550
updated source of or up to date
source of information regarding

1620
01:50:44,550 --> 01:50:48,990
the repo. And I guess the last
thing out there is, if you're a

1621
01:50:48,990 --> 01:50:55,170
developer, and you've got an
idea for a client, or like a

1622
01:50:55,170 --> 01:50:59,250
smart client that you want to
develop something like nav two,

1623
01:50:59,250 --> 01:51:02,850
or we have nav two and move it
and Ross to control that if it's

1624
01:51:02,850 --> 01:51:09,000
something like PX four, or moose
or autoware. Get in touch with

1625
01:51:09,000 --> 01:51:13,770
us, we will support you and we
want to hear from you. I'm

1626
01:51:13,770 --> 01:51:15,840
looking for artists, globally.

1627
01:51:16,890 --> 01:51:20,220
Audrow Nash: Awesome. Cool. All
right. Thank you

1628
01:51:20,999 --> 01:51:23,429
Brett Aldrich: very much. I
really had a great time. And

1629
01:51:23,579 --> 01:51:27,059
it's an honor to be interviewed.
For those just tuning into this

1630
01:51:27,059 --> 01:51:30,299
podcast. I'm Tony The sky is the
Charlie Rose of robots.

1631
01:51:31,980 --> 01:51:36,840
Audrow Nash: Thank you. Hi,
everyone. Thanks for listening

1632
01:51:36,840 --> 01:51:40,290
to this conversation with Brett
Aldrich. Thank you again to our

1633
01:51:40,290 --> 01:51:43,170
founding sponsor, open robotics
and I hope to see you next time

